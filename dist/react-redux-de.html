<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>React & Redux</title>
  <style>/*

Original highlight.js style (c) Ivan Sagalaev <maniac@softwaremaniacs.org>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #F0F0F0;
}


/* Base color: saturation 0; */

.hljs,
.hljs-subst {
  color: #444;
}

.hljs-comment {
  color: #888888;
}

.hljs-keyword,
.hljs-attribute,
.hljs-selector-tag,
.hljs-meta-keyword,
.hljs-doctag,
.hljs-name {
  font-weight: bold;
}


/* User color: hue: 0 */

.hljs-type,
.hljs-string,
.hljs-number,
.hljs-selector-id,
.hljs-selector-class,
.hljs-quote,
.hljs-template-tag,
.hljs-deletion {
  color: #880000;
}

.hljs-title,
.hljs-section {
  color: #880000;
  font-weight: bold;
}

.hljs-regexp,
.hljs-symbol,
.hljs-variable,
.hljs-template-variable,
.hljs-link,
.hljs-selector-attr,
.hljs-selector-pseudo {
  color: #BC6060;
}


/* Language color: hue: 90; */

.hljs-literal {
  color: #78A960;
}

.hljs-built_in,
.hljs-bullet,
.hljs-code,
.hljs-addition {
  color: #397300;
}


/* Meta color: hue: 200 */

.hljs-meta {
  color: #1f7199;
}

.hljs-meta-string {
  color: #4d99bf;
}


/* Misc effects */

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}
</style>
</head>

<body>
  <div id="canvas">
    <div id="canvas-content">

      <section class="section" id="section-1"><section class="slide" id="slide-1-1">
        <h1 id="redux">Redux</h1>
<h3 id="state-management-mit-redux">State management mit Redux</h3>

      </section><section class="slide" id="slide-1-2">
        <h2 id="state-management">State management</h2>
<p>In komplexeren Anwendungen macht es Sinn, den Anwendungszustand (model) von der Ansicht (view) zu trennen.</p>
<p>Oft wird der gesamte Anwendungszustand durch ein Datenmodell repräsentiert. Jede Änderung am Anwendungszustand läuft über das Datenmodell.</p>

      </section><section class="slide" id="slide-1-3">
        <h2 id="state-management-tools">State management Tools</h2>
<ul>
<li>Redux (oft mit React verwendet)</li>
<li>reducer Hook (in React beinhaltet, ähnlich zu Redux)</li>
<li>MobX (oft mit React verwendet)</li>
<li>ngrx (mit Angular verwendet)</li>
<li>vuex (mit Vue.js verwendet)</li>
</ul>

      </section><section class="slide" id="slide-1-4">
        <h2 id="besonderheit-von-redux">Besonderheit von Redux</h2>
<p>In Redux geschieht jede Zustandsänderung mittels eines <em>Reducers</em> - einer Funktion, die einen Zustand basierend auf einer <em>action</em> in den nächsten überführt</p>

      </section><section class="slide" id="slide-1-5">
        <h2 id="redux-diagramm">Redux Diagramm</h2>
<?xml version="1.0" encoding="utf-8"?>
<svg
  id="redux-flow-svg"
  version="1.1"
  width="1000"
  height="500"
  viewBox="0 0 1000 500"
  xmlns="http://www.w3.org/2000/svg"
>
  <defs>
    <g id="state">
      <circle r="60px" stroke="#000" stroke-width="2" fill="#2196f3"/>
      <text x="-15">
        state
      </text>
    </g>
    <g id="action">
      <circle r="40px" stroke="#000" stroke-width="2" fill="#f44336"/>
      <text x="-15">
        action
      </text>
    </g>
    <g id="reducer">
      <rect
        width="60"
        height="150"
        stroke="#000"
        stroke-width="2"
        fill="#9c27b0"
      />
      <text
        x="5"
        y="65"
      >
        reducer
      </text>
    </g>
    <marker id="arrow-end" refX="0.0" refY="0.0" orient="auto" style="overflow: visible;">
      <path
        transform="rotate(180)"
        d="M 8.7 4 L -2.2 0 L 8.7 -4 C 7 -1.6 7 1.6 8.7 4 z"
        class="arrowhead"
        id="path4877"
      />
    </marker>
    <path
      id="arrow-right-1"
      stroke="#000"
      stroke-width="2"
      fill="none"
      class="arrow"
      d="M0 0 L 145 0"
      marker-end="url(#arrow-end)"
    />
    <path
      id="arrow-right-2"
      stroke="#000"
      stroke-width="2"
      fill="none"
      class="arrow"
      d="M 0 0 L 65 0"
      marker-end="url(#arrow-end)"
    />
    <path
      id="arrow-right-up"
      stroke="#000"
      stroke-width="2"
      fill="none"
      class="arrow"
      d="M0 140 Q 0 0, 95 0"
      marker-end="url(#arrow-end)"
    />
  </defs>
  <style>
    #redux-flow-svg path.arrow {
      stroke: #000;
      stroke-width: 2;
      marker-end: url(#arrow-end);
      fill: none;
    }
    #redux-flow-svg {
      font-size: 16px;
      font-family: sans-serif;
    }
  </style>
  <use href="#state" transform="translate(100 100)"/>
  <use href="#state" transform="translate(500 100)"/>
  <use href="#state" transform="translate(900 100)"/>
  <use href="#action" transform="translate(210 300)"/>
  <use href="#action" transform="translate(610 300)"/>
  <use href="#reducer" transform="translate(310 40)"/>
  <use href="#reducer" transform="translate(710 40)"/>
  <use href="#arrow-right-1" transform="translate(160 100)"/>
  <use href="#arrow-right-1" transform="translate(560 100)"/>
  <use href="#arrow-right-2" transform="translate(370 100)"/>
  <use href="#arrow-right-2" transform="translate(770 100)"/>
  <use href="#arrow-right-up" transform="translate(210 120)"/>
  <use href="#arrow-right-up" transform="translate(610 120)"/>
</svg>


      </section><section class="slide" id="slide-1-6">
        <h2 id="installation">Installation</h2>
<pre><code class="language-bash">npm install redux</code></pre>

      </section><section class="slide" id="slide-1-7">
        <h2 id="einfaches-redux-beispiel-counter">Einfaches Redux-Beispiel: Counter</h2>
<p>Wir erstellen einen Counter, der eine Zahl als Zustand hat und für den die zwei Actions <em>increment</em> und <em>decrement</em> definiert sind.</p>
<p>Diese werden durch JavaScript Objekte repräsentiert:</p>
<pre><code class="language-json">{ <span class="hljs-attr">"type"</span>: <span class="hljs-string">"INCREMENT"</span> }</code></pre>
<pre><code class="language-json">{ <span class="hljs-attr">"type"</span>: <span class="hljs-string">"DECREMENT"</span> }</code></pre>

      </section><section class="slide" id="slide-1-8">
        <h2 id="einfaches-redux-beispiel-counter">Einfaches Redux-Beispiel: Counter</h2>
<p>Zentrales Element ist die <em>Reducer</em>-Funktion:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> initialState = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };

<span class="hljs-keyword">const</span> counterReducer = <span class="hljs-function">(<span class="hljs-params">state = initialState, action</span>) =&gt;</span> {
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'INCREMENT'</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span> };
    <span class="hljs-keyword">case</span> <span class="hljs-string">'DECREMENT'</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">count</span>: state.count - <span class="hljs-number">1</span> };
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
};</code></pre>

      </section><section class="slide" id="slide-1-9">
        <h2 id="einfaches-redux-beispiel-counter">Einfaches Redux-Beispiel: Counter</h2>
<p>Die Reducer-Funktion erhält als Funktionsparameter den alten Zustand (State) und eine Action, die eine Zustandsänderung beschreibt.</p>
<p>Die Reducer-Funktion gibt den neuen Zustand zurück. Wichtig: Reducer-Funktionen ändern das alte state-Objekt nicht ab, sondern erstellen ein neues (reine Funktion)</p>

      </section><section class="slide" id="slide-1-10">
        <h2 id="einfaches-redux-beispiel-counter">Einfaches Redux-Beispiel: Counter</h2>
<p>Store = Datenspeicher, der von einem Reducer verwaltet wird</p>
<pre><code class="language-js"><span class="hljs-comment">// stores.js</span>
<span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;
<span class="hljs-keyword">import</span> counterReducer <span class="hljs-keyword">from</span> <span class="hljs-string">'counterReducer'</span>;

<span class="hljs-comment">// counter = reducer</span>
<span class="hljs-keyword">const</span> counterStore = createStore(counterReducer);</code></pre>

      </section><section class="slide" id="slide-1-11">
        <h2 id="einfaches-redux-beispiel-counter">Einfaches Redux-Beispiel: Counter</h2>
<p>Store verwenden</p>
<pre><code class="language-js">counterStore.getState(); <span class="hljs-comment">// {count: 0}</span>
counterStore.dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'INCREMENT'</span> });
counterStore.getState(); <span class="hljs-comment">// {count: 1}</span></code></pre>

      </section><section class="slide" id="slide-1-12">
        <h2 id="übung">Übung</h2>
<p>Erstelle einen neuen mathadorStore mit dem Ausgangszustand <code>{number: 1}</code> und Actions für &quot;Mal 3&quot; und &quot;Minus 7&quot;</p>
<p>Zusatzaufgabe: Erreiche den Zustand 4 (oder 10) durch das dispatchen passender Actions</p>

      </section><section class="slide" id="slide-1-13">
        <h2 id="reducer-kombinieren">Reducer kombinieren</h2>
<pre><code class="language-js"><span class="hljs-keyword">const</span> rootReducer = combineReducers({
  <span class="hljs-attr">counter</span>: counterReducer,
  <span class="hljs-attr">mathador</span>: mathadorReducer,
});

<span class="hljs-keyword">const</span> rootStore = createStore(rootReducer);

rootStore.getState();
<span class="hljs-comment">// {counter: {count: 0}, mathador: {number: 1}}</span>

rootStore.dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'INCREMENT'</span> });
<span class="hljs-comment">// {counter: {count: 1}, mathador: {number: 1}}</span></code></pre>

      </section><section class="slide" id="slide-1-14">
        <h2 id="redux-devtools">Redux devtools</h2>
<p>Browser-plugin:</p>
<p><a href="https://github.com/zalmoxisus/redux-devtools-extension">https://github.com/zalmoxisus/redux-devtools-extension</a></p>

      </section><section class="slide" id="slide-1-15">
        <h2 id="redux-devtools">Redux devtools</h2>
<p>einbinden:</p>
<pre><code class="language-bash">npm install --save-dev redux-devtools-extension</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { createStore, applyMiddleware } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;
<span class="hljs-keyword">import</span> { composeWithDevTools } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-devtools-extension'</span>;

<span class="hljs-keyword">const</span> store = createStore(
  rootReducer,
  composeWithDevTools(applyMiddleware())
);</code></pre>

      </section></section><section class="section" id="section-2"><section class="slide" id="slide-2-1">
        <h1 id="immutability">Immutability</h1>

      </section><section class="slide" id="slide-2-2">
        <h2 id="immutability">Immutability</h2>
<p>(Unveränderlichkeit)</p>
<p>Wichtiges Konzept in der funktionalen Programmierung und bei React / Redux</p>

      </section><section class="slide" id="slide-2-3">
        <h2 id="immutability">Immutability</h2>
<p>Bei der Verwendung von Redux bzw von Reacts PureComponent:</p>
<p>Objekte, die den Anwendungszustand (state) beschreiben, sollten nicht direkt abgeändert werden</p>
<p>Stattdessen sollten sie durch neue Objekte ersetzt werden</p>
<p>Vorteile: Bessere Performance, mehr Möglichkeiten beim debugging</p>

      </section><section class="slide" id="slide-2-4">
        <h2 id="purecomponent">PureComponent</h2>
<p>Statt von <code>React.Component</code> ist es möglich, von <code>React.PureComponent</code> zu erben:</p>
<p>Die Entsprechende Komponente wird nur neu gerendert, wenn sich entweder state oder props geändert haben.</p>
<p>In einer PureComponent gelten Einträge in state bzw props dann als geändert, wenn sie sich auf ein anderes Objekt als zuvor beziehen</p>

      </section><section class="slide" id="slide-2-5">
        <h2 id="verwaltung-von-daten-ohne-mutationen">Verwaltung von Daten ohne Mutationen</h2>

      </section><section class="slide" id="slide-2-6">
        <h2 id="datenverwaltung-ohne-mutationen-arrays">Datenverwaltung ohne Mutationen: Arrays</h2>
<pre><code class="language-js"><span class="hljs-keyword">let</span> names = [<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Charlie'</span>];
<span class="hljs-comment">// nicht zulässig: verändert das ursprüngliche array</span>
names.push(<span class="hljs-string">'Dan'</span>);

<span class="hljs-comment">// stattdessen: neues Array;</span>
<span class="hljs-keyword">let</span> newNames = names.slice();
newNames.push(<span class="hljs-string">'Dan'</span>);
<span class="hljs-comment">// überschreiben des ursprünglichen Arrays</span>
names = newNames;

<span class="hljs-comment">// oder:</span>
names = [...names, <span class="hljs-string">'Dan'</span>];</code></pre>

      </section><section class="slide" id="slide-2-7">
        <h2 id="datenverwaltung-ohne-mutationen-objekt">Datenverwaltung ohne Mutationen: Objekt</h2>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'john'</span>
  email: <span class="hljs-string">'john@doe.com'</span>
}
<span class="hljs-comment">// nicht zulässig: verändert das Objekt</span>
user.email = <span class="hljs-string">'johndoe@gmail.com'</span>;

<span class="hljs-comment">// stattedessen: Erzeugen eines neuen Objekts:</span>
<span class="hljs-keyword">let</span> newUser = { ...user, <span class="hljs-attr">email</span>: <span class="hljs-string">'johndoe@gmail.com'</span> };</code></pre>

      </section><section class="slide" id="slide-2-8">
        <h2 id="immutablejs">immutable.js</h2>
<p><strong>immutable.js</strong> ist eine Library, die das Arbeiten ohne Mutationen noch erleichtert</p>
<p>Immutable.js bietet insbesondere die Datenstrukturen <em>List</em> und <em>Map</em>, die als unveränderliche Alternativen zu <em>Array</em> und <em>Object</em> dienen können.</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { List, <span class="hljs-built_in">Map</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'immutable'</span>;

<span class="hljs-keyword">const</span> a1 = List([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
<span class="hljs-keyword">const</span> a2 = a1.push(<span class="hljs-number">4</span>);

<span class="hljs-keyword">const</span> b1 = <span class="hljs-built_in">Map</span>({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> });
<span class="hljs-keyword">const</span> b2 = b1.set(<span class="hljs-string">'b'</span>, <span class="hljs-literal">null</span>);</code></pre>

      </section><section class="slide" id="slide-2-9">
        <h2 id="immutablejs">immutable.js</h2>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { fromJS, setIn } <span class="hljs-keyword">from</span> <span class="hljs-string">'immutable'</span>;

<span class="hljs-keyword">const</span> todos = fromJS([
  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'groceries'</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'gardening'</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span> },
]);

<span class="hljs-keyword">const</span> newTodos = todos.setIn([<span class="hljs-number">1</span>, <span class="hljs-string">'completed'</span>], <span class="hljs-literal">true</span>);</code></pre>

      </section></section><section class="section" id="section-3"><section class="slide" id="slide-3-1">
        <h1 id="aufgabe-todolist">Aufgabe: Todolist</h1>
<p>Umsetzung eines Modells für eine Todoliste in Redux</p>

      </section><section class="slide" id="slide-3-2">
        <h2 id="aufgabe-todolist">Aufgabe: Todolist</h2>
<p>Datenstruktur (Beispiel):</p>
<ul>
<li>todoData<ul>
<li>todos</li>
<li>isFetching</li>
<li>hasError</li>
</ul>
</li>
<li>ui<ul>
<li>newTodoTitle</li>
<li>filterText</li>
</ul>
</li>
</ul>

      </section><section class="slide" id="slide-3-3">
        <h2 id="aufgabe-todolist">Aufgabe: Todolist</h2>
<p>Actions (Beispiel):</p>
<ul>
<li>addTodo</li>
<li>toggleTodo</li>
<li>deleteTodo</li>
<li>loadTodosFromApi</li>
</ul>

      </section></section><section class="section" id="section-4"><section class="slide" id="slide-4-1">
        <h1 id="selektoren">Selektoren</h1>

      </section><section class="slide" id="slide-4-2">
        <h2 id="speicherung-des-minimalen-states">Speicherung des minimalen States</h2>
<p>Best Practice in Redux: Immer den <em>minimalen</em> State speichern (keine redundanten Daten)</p>
<p>Negativbeispiele:</p>
<pre><code class="language-js">{
  <span class="hljs-attr">todos</span>: [...],
  <span class="hljs-attr">maxTodoId</span>: <span class="hljs-number">3</span>
}</code></pre>
<pre><code class="language-js">{
  <span class="hljs-attr">shoppingCartItems</span>: [{<span class="hljs-attr">itemid</span>: ..., <span class="hljs-attr">price</span>: ...}, ...],
  <span class="hljs-attr">totalPrice</span>: ...
}</code></pre>

      </section><section class="slide" id="slide-4-3">
        <h2 id="sepeicherung-des-minimalen-states">Sepeicherung des minimalen States</h2>
<p>Daten wie <code>maxTodoId</code> und <code>totalPrice</code> können aus den anderen Daten abgeleitet werden und sollten keinen separaten Eintrag im State haben.</p>

      </section><section class="slide" id="slide-4-4">
        <h2 id="selektoren">Selektoren</h2>
<p>Selektor = Funktion, die abgeleitete Daten aus einem minimalen State errechnet</p>
<p>Ein Selektor erhält den ganzen State als Argument und gibt abgeleitete Daten zurück</p>

      </section><section class="slide" id="slide-4-5">
        <h2 id="beispiele-für-selektoren">Beispiele für Selektoren</h2>
<ul>
<li><code>getMaxTodoId</code></li>
<li><code>getFilteredTodos</code></li>
</ul>

      </section><section class="slide" id="slide-4-6">
        <h2 id="beispiele-für-selektoren">Beispiele für Selektoren</h2>
<pre><code class="language-js"><span class="hljs-keyword">const</span> getMaxTodoId = <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span>
  state.todos.reduce(<span class="hljs-function">(<span class="hljs-params">aggregator, item</span>) =&gt;</span>
    <span class="hljs-built_in">Math</span>.max(aggregator, item.id, <span class="hljs-number">1</span>)
  );</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">const</span> getFilteredTodos = <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span>
  state.todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span>
    todo.title
      .toLowerCase()
      .includes(state.ui.filterText.toLowerCase())
  );</code></pre>

      </section></section><section class="section" id="section-5"><section class="slide" id="slide-5-1">
        <h1 id="memoisierte-selektoren">Memoisierte Selektoren</h1>

      </section><section class="slide" id="slide-5-2">
        <h2 id="memoisierung">Memoisierung</h2>
<p>Memoisierung bezeichnet das Cachen von Rückgabewerten reiner Funktionen</p>

      </section><section class="slide" id="slide-5-3">
        <h2 id="memoisierung-in-reselect">Memoisierung in reselect</h2>
<p><em>Reselect</em> = Library für Memoisierung.</p>
<p>Einfaches Standardverhalten:</p>
<p>Letzter Input und Output einer Berechnung werden gecacht; Wird die Berechnung erneut mit dem gleichen Input angefordert, wird das gecachte Resultat verwendet</p>

      </section><section class="slide" id="slide-5-4">
        <h2 id="memoisierung-in-reselect">Memoisierung in reselect</h2>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { createSelector } <span class="hljs-keyword">from</span> <span class="hljs-string">'reselect'</span>;

<span class="hljs-comment">// regular function that computes the area of a rectangle</span>
<span class="hljs-keyword">const</span> getRectArea = <span class="hljs-function"><span class="hljs-params">rect</span> =&gt;</span> rect.length * rect.width;

<span class="hljs-comment">// memoized function that computes the area of a rectangle</span>
<span class="hljs-keyword">const</span> getRectAreaMemoized = createSelector(
  <span class="hljs-comment">// selector functions signify which input values to watch:</span>
  [<span class="hljs-function"><span class="hljs-params">rect</span> =&gt;</span> rect.length, rect =&gt; rect.width],
  <span class="hljs-comment">// this function will only be called if one of the</span>
  <span class="hljs-comment">// input values changed:</span>
  (length, width) =&gt; length * width
);</code></pre>

      </section><section class="slide" id="slide-5-5">
        <h2 id="memoisierung-in-reselect">Memoisierung in reselect</h2>
<p>The last function call will not recompute the area</p>
<pre><code class="language-js">getRectArea({ <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">color</span>: <span class="hljs-string">'blue'</span> });
getRectArea({ <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span> });

getRectAreaMemoized({ <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">color</span>: <span class="hljs-string">'blue'</span> });
getRectAreaMemoized({ <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span> });</code></pre>

      </section><section class="slide" id="slide-5-6">
        <h2 id="reselect-installieren">Reselect installieren</h2>
<pre><code class="language-bash">npm install reselect</code></pre>

      </section></section><section class="section" id="section-6"><section class="slide" id="slide-6-1">
        <h1 id="redux-im-detail">Redux im Detail</h1>

      </section><section class="slide" id="slide-6-2">
        <h2 id="elemente-von-redux">Elemente von Redux</h2>
<ul>
<li><em>state</em>: Anwendungszustand</li>
<li><em>action</em>: Beschreibt eine Änderung am <em>state</em></li>
<li><em>action creator</em>: Erzeugt eine <em>action</em></li>
<li><em>reducer</em>: Führt einen <em>state</em> basierend auf einer <em>action</em> in einen nächsten <em>state</em> über</li>
<li><em>store</em>: Ort der Speicherung für <em>state</em></li>
</ul>

      </section><section class="slide" id="slide-6-3">
        <h2 id="beispiel-state">Beispiel: state</h2>
<pre><code class="language-js">{
  <span class="hljs-attr">todos</span>: [
    { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'laundry'</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span> },
    { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'groceries'</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">true</span> },
    { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'taxes'</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span> },
  ],
  <span class="hljs-attr">filterText</span>: <span class="hljs-string">''</span>,
}</code></pre>

      </section><section class="slide" id="slide-6-4">
        <h2 id="actions">Actions</h2>
<ul>
<li>Beschreiben eine Zustandsänderung</li>
<li>Sind js-Objekte mit einer <em>type</em>-Property und <em>optional</em> beliebigen anderen Properties</li>
<li>Die <em>type</em>-Property ist üblicherweise ein String, oft als Konstante in einem separaten Modul definiert</li>
<li>Actions werden oft nach dem <em>FSA</em>-Standard definiert, der eine <code>payload</code>-Property definiert, sowie <code>error</code> und <code>meta</code></li>
</ul>

      </section><section class="slide" id="slide-6-5">
        <h2 id="actions---beispiele">Actions - Beispiele</h2>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { ADD_TODO } <span class="hljs-keyword">from</span> <span class="hljs-string">'./constants'</span>;

<span class="hljs-keyword">let</span> a = {
  <span class="hljs-attr">type</span>: ADD_TODO,
  <span class="hljs-attr">payload</span>: {
    <span class="hljs-attr">title</span>: <span class="hljs-string">'Build my first redux app'</span>,
  },
};</code></pre>

      </section><section class="slide" id="slide-6-6">
        <h2 id="actions---beispiele">Actions - Beispiele</h2>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = {
  <span class="hljs-attr">type</span>: TOGGLE_TODO,
  <span class="hljs-attr">payload</span>: {
    <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,
  },
};</code></pre>

      </section><section class="slide" id="slide-6-7">
        <h2 id="action-creators">Action Creators</h2>
<p>Action creators sind meist sehr einfache Funktionen, die eine bestimmte Action erstellen</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> addTodo = <span class="hljs-function">(<span class="hljs-params">title, completed = <span class="hljs-literal">false</span></span>) =&gt;</span> ({
  <span class="hljs-attr">type</span>: ADD_TODO,
  <span class="hljs-attr">payload</span>: {
    <span class="hljs-attr">title</span>: title,
    <span class="hljs-attr">completed</span>: completed,
  },
});</code></pre>

      </section><section class="slide" id="slide-6-8">
        <h2 id="beispiel-todo-verwaltung-mit-redux">Beispiel: Todo-Verwaltung mit Redux</h2>

      </section></section><section class="section" id="section-7"><section class="slide" id="slide-7-1">
        <h1 id="asynchrone-actions">Asynchrone Actions</h1>

      </section><section class="slide" id="slide-7-2">
        <h2 id="asynchrone-actions">Asynchrone Actions</h2>
<p>Asynchrone Actions betreffen beispielsweise HTTP-Anfragen oder das Abfragen von Caches oder indexedDB-Einträgen.</p>
<p>Asynchrone Actions können in Redux mit <em>middleware</em> realisiert werden, z.B.:</p>
<ul>
<li><em>thunk</em></li>
<li><em>saga</em></li>
</ul>

      </section></section><section class="section" id="section-8"><section class="slide" id="slide-8-1">
        <h1 id="redux-thunk">Redux Thunk</h1>

      </section><section class="slide" id="slide-8-2">
        <h2 id="redux-thunk">Redux Thunk</h2>
<p>Thunk ist Middleware, die asynchrones Verhalten in Redux - durch das Dispatchen von Funktionen - ermöglicht</p>

      </section><section class="slide" id="slide-8-3">
        <h2 id="thunk-sourcecode">Thunk sourcecode</h2>
<p>kompletter sourcecode:</p>
<p><a href="https://github.com/reduxjs/redux-thunk/blob/master/src/index.js">https://github.com/reduxjs/redux-thunk/blob/master/src/index.js</a></p>

      </section><section class="slide" id="slide-8-4">
        <h2 id="redux-thunk">Redux Thunk</h2>
<p>Beispielhafter Aufruf:</p>
<pre><code class="language-js">dispatch(getTodosFunction);</code></pre>

      </section><section class="slide" id="slide-8-5">
        <h2 id="redux-thunk">Redux Thunk</h2>
<p>Als asynchrone Funktion würde <code>getTodosFunction</code> nicht direkt den Redux-Store verändern.</p>
<p>Stattdessen würde zwei andere Actions den store erreichen:</p>
<ul>
<li>Die Action <code>LOAD_TODOS_REQUEST</code> würde sofort dispatched werden</li>
<li>Die Action <code>LOAD_TODOS_SUCCESS</code> würde dispatched werden, sobald die Netzwerkanfrage erfolgreich war</li>
</ul>

      </section><section class="slide" id="slide-8-6">
        <h2 id="redux-thunk">Redux Thunk</h2>
<p>In Thunk verbleibt die synchrone Logik im Reducer.</p>
<p>Die asynchrone Logik wird in den Action Creator aufgenommen.</p>

      </section><section class="slide" id="slide-8-7">
        <h2 id="installation">Installation</h2>
<pre><code class="language-bash">npm install redux-thunk</code></pre>

      </section><section class="slide" id="slide-8-8">
        <h2 id="thunk-einbinden">Thunk einbinden</h2>
<pre><code class="language-ts"><span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-thunk'</span>;

<span class="hljs-keyword">const</span> store = createStore(
  rootReducer,
  applyMiddleware(thunk)
);</code></pre>

      </section><section class="slide" id="slide-8-9">
        <h2 id="beispiel-timer">Beispiel: timer</h2>
<pre><code class="language-js"><span class="hljs-comment">// sync actions</span>
<span class="hljs-keyword">const</span> started = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({ <span class="hljs-attr">type</span>: <span class="hljs-string">'START'</span> });
<span class="hljs-keyword">const</span> increment = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({ <span class="hljs-attr">type</span>: <span class="hljs-string">'INCREMENT'</span> });
<span class="hljs-comment">// async action</span>
<span class="hljs-keyword">const</span> start = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> dispatch =&gt; {
  dispatch(started());
  setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    dispatch(increment());
  }, <span class="hljs-number">1000</span>);
};</code></pre>

      </section><section class="slide" id="slide-8-10">
        <h2 id="beispiel-timer">Beispiel: timer</h2>
<p>Der Reducer erhält nur die synchronen Actions.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> timeReducer = (
  state = { <span class="hljs-attr">started</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">time</span>: <span class="hljs-number">0</span> },
  action
) =&gt; {
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'INCREMENT'</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">time</span>: state.time + <span class="hljs-number">1</span> };
    <span class="hljs-keyword">case</span> <span class="hljs-string">'STARTED'</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">started</span>: <span class="hljs-literal">true</span> };
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
};</code></pre>

      </section><section class="slide" id="slide-8-11">
        <h2 id="redux-thunk-mit-typescript">Redux Thunk mit TypeScript</h2>
<p>Bei Thunk müssen wir immer die gesamte Signatur von dispatch angeben</p>
<pre><code class="language-ts"><span class="hljs-keyword">const</span> mapDispatchToProps = (
  dispatch: ThunkDispatch&lt;IState, <span class="hljs-built_in">void</span>, IAction&gt;
) =&gt; {...};</code></pre>
<pre><code class="language-ts"><span class="hljs-keyword">const</span> myAction = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  dispatch: ThunkDispatch&lt;IState, <span class="hljs-built_in">void</span>, IAction&gt;
) =&gt; {...};</code></pre>

      </section><section class="slide" id="slide-8-12">
        <h2 id="thunk-zugriff-auf-den-redux-store">Thunk: Zugriff auf den Redux store</h2>
<p>Ein zweites Argument kann optional übergeben werden: Es erhält die <code>getState</code>-Funktion als Wert.</p>
<pre><code class="language-ts"><span class="hljs-keyword">const</span> actionAsync = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (dispatch, getState) =&gt; {
  dispatch(started());
  <span class="hljs-keyword">const</span> s = getState();
  ...
};</code></pre>

      </section><section class="slide" id="slide-8-13">
        <h2 id="aufgabe-todos-von-rest-api-laden">Aufgabe: Todos von REST API laden</h2>
<p>Erstelle ein thunk, das Todos vom folgenden API lädt:</p>
<p><code>https://jsonplaceholder.typicode.com/todos</code></p>

      </section></section><section class="section" id="section-9"><section class="slide" id="slide-9-1">
        <h1 id="iterables-iterators-und-generators">Iterables, Iterators und Generators</h1>

      </section><section class="slide" id="slide-9-2">
        <h2 id="iterable">Iterable</h2>
<p>Iterable = Objekt, über das mit <code>for ... of</code> iteriert werden kann</p>
<p>Beispiele: Arrays, Iterators</p>
<p>Iterables definieren eine Methode unter dem Symbol <code>Symbol.iterator</code></p>

      </section><section class="slide" id="slide-9-3">
        <h2 id="iterators">Iterators</h2>
<p>Oberflächlich: Ein Iterator ist ein besonderes Objekt, über das wir mit <code>for (let item of iterator)</code> iterieren können.</p>
<p>Genauer Hintergrund: Ein Iterator ist ein besonderes Objekt, das eine <code>next</code>-Methode besitzt.</p>
<p>Iterators können auf verschiedene Arten erzeugt werden.</p>

      </section><section class="slide" id="slide-9-4">
        <h2 id="generator-funktionen">Generator-Funktionen</h2>
<p>Eine Generator-Funktion ist eine Möglichkeit, einen Iterator zu erstellen. Eine Generator-Funktion kann wiederholt betreten und verlassen werden. Sie &quot;merkt&quot; sich in der Zwischenzeit ihren Zustand.</p>

      </section><section class="slide" id="slide-9-5">
        <h2 id="generator-funktionen">Generator-Funktionen</h2>
<p>Eine Funktion kann mit <code>function*</code> definiert werden und anstatt eines <code>return</code>-Statements ein <code>yield</code> Statement enthalten - sie wird damit zu einer Generator-Funktion, die beim Aufruf einen Iterator zurückgibt.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">countTo100</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-number">100</span>) {
    <span class="hljs-keyword">yield</span> i;
    i++;
  }
}</code></pre>

      </section><section class="slide" id="slide-9-6">
        <h2 id="generator-funktionen">Generator-Funktionen</h2>
<p>Verwendung:</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> countTo100()) {
  <span class="hljs-built_in">console</span>.log(i);
}</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">const</span> c = countTo100();
<span class="hljs-keyword">const</span> firstEnetry = c.next();
<span class="hljs-built_in">console</span>.log(firstEntry.value);
<span class="hljs-keyword">const</span> secondEntry = c.next();
<span class="hljs-built_in">console</span>.log(secondEntry.value);</code></pre>

      </section></section><section class="section" id="section-10"><section class="slide" id="slide-10-1">
        <h1 id="redux-saga">Redux Saga</h1>

      </section><section class="slide" id="slide-10-2">
        <h2 id="redux-saga">Redux Saga</h2>
<p>Wie auch bei Thunk handelt es sich bei Saga um Middleware, die asynchrones Verhalten in Redux ermöglicht</p>

      </section><section class="slide" id="slide-10-3">
        <h2 id="installation">Installation</h2>
<pre><code class="language-bash">npm install redux-saga</code></pre>

      </section><section class="slide" id="slide-10-4">
        <h2 id="saga-middleware-einbinden">Saga Middleware einbinden</h2>
<pre><code class="language-js"><span class="hljs-keyword">import</span> createSagaMiddleWare <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-saga'</span>;

<span class="hljs-keyword">const</span> sagaMiddleware = createSagaMiddleware();

<span class="hljs-keyword">const</span> store = createStore(
  rootReducer,
  applyMiddleware(sagaMiddleWare)
);</code></pre>

      </section><section class="slide" id="slide-10-5">
        <h2 id="ein-saga-ausführen">Ein Saga ausführen</h2>
<p>Ein Saga ist ähnlich einem separaten Thread in unserer Anwendung, der für side effects verantwortlich ist.</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> todoSaga <span class="hljs-keyword">from</span> <span class="hljs-string">'./todosaga'</span>;

sagaMiddleware.run(todoSaga);</code></pre>

      </section><section class="slide" id="slide-10-6">
        <h2 id="ein-saga-definieren">Ein Saga definieren</h2>
<p>Sagas werden als Generators definiert</p>
<p>Der folgende Code bewirkt, dass z.B. <code>TODOS_FETCH_REQUEST</code> von <code>fetchTodos</code> behandelt wird.</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { takeEvery } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-saga/effects'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">todoSaga</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> takeEvery(<span class="hljs-string">'TODOS_FETCH_REQUEST'</span>, fetchTodos);
  <span class="hljs-keyword">yield</span> takeEvery(<span class="hljs-string">'USERS_FETCH_REQUEST'</span>, fetchUsers);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> todoSaga;</code></pre>

      </section><section class="slide" id="slide-10-7">
        <h2 id="asynchrone-logik-mittels-async-und-await">Asynchrone Logik mittels async und await</h2>
<p>Asynchrone Funktionen mittels <code>async</code> und <code>await</code> sind seit ES2017 im JavaScript Standard</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> url = <span class="hljs-string">'https://jsonplaceholder.typicode.com/todos'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchTodos</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(url);
  <span class="hljs-keyword">const</span> todoData = <span class="hljs-keyword">await</span> response.json();
  <span class="hljs-built_in">console</span>.log(todoData);
}</code></pre>

      </section><section class="slide" id="slide-10-8">
        <h2 id="asynchrone-logik-mittels-generators">Asynchrone Logik mittels Generators</h2>
<p>Redux-Saga setzt etwas ganz ähnliches mittels Generators um:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> url = <span class="hljs-string">'https://jsonplaceholder.typicode.com/todos'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fetchTodos</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">yield</span> fetch(url);
  <span class="hljs-keyword">const</span> todoData = <span class="hljs-keyword">yield</span> response.json();
  <span class="hljs-built_in">console</span>.log(todoData);
}</code></pre>
<p>(<a href="https://gist.github.com/jakearchibald/31b89cba627924972ad6">Benötigter Code zum Ausführen dieses Beispiels</a>)</p>

      </section><section class="slide" id="slide-10-9">
        <h2 id="redux-actions-aus-saga-dispatchen">Redux Actions aus Saga dispatchen</h2>
<p>mittels <code>put</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { put } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-saga/effects'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fetchTodos</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">yield</span> fetch(url);
  <span class="hljs-keyword">const</span> todoData = <span class="hljs-keyword">yield</span> response.json();
  <span class="hljs-keyword">yield</span> put({
    <span class="hljs-attr">type</span>: <span class="hljs-string">'TODOS_FETCH_SUCCESS'</span>,
    <span class="hljs-attr">payload</span>: todoData,
  });
}</code></pre>

      </section><section class="slide" id="slide-10-10">
        <h2 id="saga-mit-fehlerbehandlung">Saga mit Fehlerbehandlung</h2>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { put } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-saga/effects'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fetchTodos</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">yield</span> fetch(url);
  <span class="hljs-keyword">if</span> (response.ok) {
    <span class="hljs-keyword">const</span> todoData = <span class="hljs-keyword">yield</span> response.json();
    <span class="hljs-keyword">yield</span> put({
      <span class="hljs-attr">type</span>: <span class="hljs-string">'TODOS_FETCH_SUCCESS'</span>,
      <span class="hljs-attr">payload</span>: todoData,
    });
  } <span class="hljs-keyword">else</span> {
    cield put({
      <span class="hljs-attr">type</span>: <span class="hljs-string">'TODOS_FETCH_ERROR'</span>
    })
  }
}</code></pre>

      </section></section><section class="section" id="section-11"><section class="slide" id="slide-11-1">
        <h1 id="redux-ecosystem">Redux Ecosystem</h1>

      </section><section class="slide" id="slide-11-2">
        <h2 id="redux-ecosystem---beispiele">Redux Ecosystem - Beispiele</h2>
<ul>
<li>redux-logger</li>
<li>redux-thunk: asynchrone Actions</li>
<li>redux-saga: asynchrone Actions</li>
<li>normalizr: normalisierte Struktur für state</li>
<li>reselect: Performanceverbesserung via Memoisation</li>
<li>redux-actions: Boilerplate-Reduktion (createAction, createReducer)</li>
<li>immutable.js</li>
</ul>

      </section><section class="slide" id="slide-11-3">
        <h2 id="redux-middleware">Redux Middleware</h2>
<ul>
<li>kann zu einem Redux Store hinzugefügt werden</li>
<li>Erweiterungspunkt / Eingriffspunkt zwischen dem Dispatchen einer Aktion und dem Zeitpunkt an dem sie beim Reducer eintrifft</li>
</ul>

      </section><section class="slide" id="slide-11-4">
        <h2 id="redux-middleware---beispiele">Redux Middleware - Beispiele</h2>
<ul>
<li>Middleware, die eine action loggt (zB redux-logger)</li>
<li>Middleware, die eine einzelne action erhält und basierend darauf verschiedene andere actions asynchron auslöst (zB redux-thunk)</li>
</ul>

      </section><section class="slide" id="slide-11-5">
        <h2 id="redux-middleware---implementierung">Redux Middleware - Implementierung</h2>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myLogger = <span class="hljs-function"><span class="hljs-params">store</span> =&gt;</span> next =&gt; <span class="hljs-function"><span class="hljs-params">action</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(action);
  next(action);
};</code></pre>

      </section><section class="slide" id="slide-11-6">
        <h2 id="redux-middleware---einbindung">Redux Middleware - Einbindung</h2>
<pre><code class="language-ts"><span class="hljs-keyword">const</span> store = createStore(
  rootReducer,
  applyMiddleware(myLogger)
);</code></pre>

      </section><section class="slide" id="slide-11-7">
        <h2 id="eigene-middleware---json-fetcher">Eigene Middleware - json fetcher</h2>
<p>Beispielhafte Nutzung:</p>
<pre><code class="language-js">dispatch({
  <span class="hljs-attr">type</span>: <span class="hljs-string">'FETCH_JSON'</span>,
  <span class="hljs-attr">payload</span>: {
    <span class="hljs-attr">url</span>: <span class="hljs-string">'https://jsonplaceholder.typicode.com/todos'</span>,
  },
});</code></pre>

      </section><section class="slide" id="slide-11-8">
        <h2 id="eigene-middleware---json-fetcher">Eigene Middleware - json fetcher</h2>
<p>Die action <code>FETCH_JSON</code> sollte im Hintergrund zwei einzelne actions dispatchen:</p>
<ul>
<li><code>FETCH_JSON_START</code></li>
<li><code>FETCH_JSON_COMPLETE</code> (diese enthält auch JSON-daten als payload)</li>
</ul>

      </section><section class="slide" id="slide-11-9">
        <h2 id="eigene-middleware---json-fetcher">Eigene Middleware - json fetcher</h2>
<pre><code class="language-js"><span class="hljs-keyword">const</span> fetcher = <span class="hljs-function"><span class="hljs-params">store</span> =&gt;</span> next =&gt; <span class="hljs-function"><span class="hljs-params">action</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (action.type === <span class="hljs-string">'FETCH_JSON'</span>) {
    store.dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'FETCH_JSON_START'</span> });
    fetch(action.payload.url)
      .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
      .then(<span class="hljs-function"><span class="hljs-params">parsedResponse</span> =&gt;</span> {
        store.dispatch({
          <span class="hljs-attr">type</span>: <span class="hljs-string">'FETCH_JSON_COMPLETE'</span>,
          <span class="hljs-attr">requestedUrl</span>: url,
          <span class="hljs-attr">response</span>: parsedResponse,
        });
      });
  } <span class="hljs-keyword">else</span> {
    next(action);
  }
};</code></pre>

      </section><section class="slide" id="slide-11-10">
        <h2 id="eigene-middleware---eine-funktion-dispatchen">Eigene Middleware - eine Funktion dispatchen</h2>
<p>Wir wollen noch flexibler sein und eine Funktion dispatchen.</p>
<p>Diese Funktion soll asynchrone Anfragen durchführen und weitere Actions dispatchen können.</p>

      </section><section class="slide" id="slide-11-11">
        <h2 id="eigene-middleware---eine-funktion-dispatchen">Eigene Middleware - eine Funktion dispatchen</h2>
<pre><code class="language-js"><span class="hljs-keyword">const</span> functionMiddleware = <span class="hljs-function"><span class="hljs-params">store</span> =&gt;</span> next =&gt; <span class="hljs-function"><span class="hljs-params">action</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> action === <span class="hljs-string">'function'</span>) {
    <span class="hljs-comment">// we pass dispatch to the action function</span>
    <span class="hljs-comment">// so the action can call it</span>
    <span class="hljs-keyword">return</span> action(store.dispatch);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> next(action);
  }
};</code></pre>

      </section><section class="slide" id="slide-11-12">
        <h2 id="präsentation-taming-large-react-applications-w-redux">Präsentation: Taming Large React Applications w/ Redux</h2>
<p><a href="https://slides.com/joelkanzelmeyer/taming-large-redux-apps">https://slides.com/joelkanzelmeyer/taming-large-redux-apps</a></p>

      </section></section><section class="section" id="section-12"><section class="slide" id="slide-12-1">
        <h1 id="react-mit-redux">React mit Redux</h1>

      </section><section class="slide" id="slide-12-2">
        <h2 id="react-mit-redux">React mit Redux</h2>
<p><a href="https://redux.js.org/basics/usage-with-react">https://redux.js.org/basics/usage-with-react</a></p>
<p>Setup: <code>npm install redux react-redux</code></p>
<p>Typescript: <code>npm install @types/react-redux</code></p>

      </section><section class="slide" id="slide-12-3">
        <h2 id="presentational-und-container-components">Presentational und Container Components</h2>
<ul>
<li>presentational components: &quot;Normale&quot; React-Komponenten (wiederverwendbar)</li>
<li>container components: Zugriff auf Redux-Store / Mit dem Redux-Store verbunden</li>
</ul>

      </section><section class="slide" id="slide-12-4">
        <h2 id="react-redux--provider">React-Redux: &lt; Provider &gt;</h2>
<p>Provider: Hinzufügen von Redux-Store zu einer React-App</p>

      </section><section class="slide" id="slide-12-5">
        <h2 id="react-redux--provider">React-Redux: &lt; Provider &gt;</h2>
<pre><code class="language-js"><span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">import</span> { Provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;

[...]

ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{myStore}</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>
  ...
);</code></pre>

      </section><section class="slide" id="slide-12-6">
        <h2 id="counter-connect">Counter: Connect</h2>
<p>connect: verbindet React-Komponenten mit dem Redux store</p>
<ul>
<li><code>mapStateToProps</code>: verbindet React props mit Redux state</li>
<li><code>mapDispatchToProps</code>: verbindet React props mit Redux actions</li>
</ul>
<p>Aufruf:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> ConnectedComponent = connect(
  mapStateToProps,
  mapDispatchToProps
)(Component);</code></pre>

      </section><section class="slide" id="slide-12-7">
        <h2 id="counter-connect-state">Counter: Connect (state)</h2>
<pre><code class="language-jsx">import { connect } from 'react-redux';

const mapStateToProps = (state) =&gt; ({ count: state });
}

[...]
    &lt;div className="App"&gt;
      {JSON.stringify(this.props)}
    &lt;/div&gt;
[...]

export default connect(mapStateToProps)(App);</code></pre>

      </section><section class="slide" id="slide-12-8">
        <h2 id="counter-connect-actions">Counter: Connect (actions)</h2>
<pre><code class="language-jsx"><span class="hljs-keyword">const</span> mapDispatchToProps = <span class="hljs-function"><span class="hljs-params">dispatch</span> =&gt;</span> ({
  <span class="hljs-comment">// dispatch ist die dispatch-Funktion des Stores.</span>
  <span class="hljs-comment">// sie wird uns hier mittels dependency injection</span>
  <span class="hljs-comment">// zur Verfügung gestellt</span>
  increment: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'INCREMENT'</span> }),
  <span class="hljs-attr">decrement</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'DECREMENT'</span> }),
});</code></pre>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.props.increment}</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.props.decrement}</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre>

      </section><section class="slide" id="slide-12-9">
        <h2 id="counter-dispatch-mit-typescript">Counter: Dispatch mit TypeScript</h2>
<pre><code class="language-ts"><span class="hljs-keyword">import</span> { Action, Dispatch } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;

<span class="hljs-keyword">interface</span> MyAction <span class="hljs-keyword">extends</span> Action {
  payload: <span class="hljs-built_in">any</span>;
}

<span class="hljs-keyword">const</span> mapDispatchToProps = (
  dispatch: Dispatch&lt;MyAction&gt;
) =&gt; ({
  increment: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    dispatch({ <span class="hljs-keyword">type</span>: <span class="hljs-string">'INCREMENT'</span>, payload: <span class="hljs-number">1</span> });
  },
});</code></pre>

      </section><section class="slide" id="slide-12-10">
        <h2 id="redux-mit-typescript">Redux mit TypeScript</h2>
<p>siehe:</p>
<ul>
<li><a href="https://github.com/piotrwitek/react-redux-typescript-guide">https://github.com/piotrwitek/react-redux-typescript-guide</a></li>
<li><a href="https://medium.com/@resir014/a-type-safe-approach-to-redux-stores-in-typescript-6474e012b81e">https://medium.com/@resir014/a-type-safe-approach-to-redux-stores-in-typescript-6474e012b81e</a></li>
<li><a href="https://www.carlrippon.com/strongly-typed-react-redux-code-with-typescript/">https://www.carlrippon.com/strongly-typed-react-redux-code-with-typescript/</a></li>
</ul>

      </section></section>

    </div>
    <div id="navigation-arrows">
      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="navigation-arrows-svg"
        xml:space="preserve" width="100%" height="100%" viewBox="-110 -110 220 220">
        <path class="arrow right" d="M70,-30L100,0L70,30" />
        <path class="arrow down" d="M-30,70L0,100L30,70" />
        <path class="arrow left" d="M-70,-30L-100,0L-70,30" />
        <path class="arrow up" d="M-30,-70L0,-100L30,-70" />
      </svg>
    </div>
  </div>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      width: 100vw;
      height: 100vh;
      margin: 0px;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: rgb(150, 150, 150);
      font-family: -apple-system, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
      line-height: 1.5rem;
    }

    p, ul, pre {
      margin-top: 0;
    }

    ul {
      padding-left: 1.5rem;
    }

    h1, h2, h3 {
      margin-top: 0px;
      font-weight: 600;
    }

    h1 {
      margin-top: 5vh;
      text-align: center;
      font-size: 2rem;
    }

    h2 {
      margin-bottom: 1.5em;
    }

    svg {
      width: 100%;
      height: auto;
    }

    .section {
      height: 100%;
      display: none;
    }

    .section.active {
      display: block;
    }

    .slide {
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    .slide.inactive {
      display: none;
    }

    #canvas {
      box-shadow: 0 0.5vh 1vh rgba(0, 0, 0, 0.3);
      background-color: #f8f8f8;
      position: relative;
      display: flex;
    }

    #canvas-content {
      width: 100%;
      height: 100%;
    }

    #canvas-content .note {
      display: none;
    }

    #canvas-content img {
      margin: 0px auto;
      display: block;
    }

    @media (min-aspect-ratio: 8/5) {

      html {
        font-size: 3.5vh;
      }

      /* wide screen */
      #canvas {
        width: calc(100vh / 5 * 8);
        height: 100vh;
        padding: 10vh;
        padding-top: 5vh;
      }
    }

    @media (max-aspect-ratio: 8/5) {

      html {
        font-size: calc(3.5vw * 5 / 8);
      }

      /* narrow screen */
      #canvas {
        width: 100vw;
        height: calc(100vw * 5 / 8);
        padding: calc(10vh * 5 / 8);
        padding-top: calc(5vh * 5 / 8);
      }
    }

    pre {
      background-color: rgb(224, 233, 240);
      box-shadow: 0 0.5vh 1vh rgba(0, 0, 0, 0.2);
      padding: 0.5em 1em;
      line-height: 1.2em;
      overflow: auto;
    }

    #navigation-arrows {
      position: absolute;
      right: 2rem;
      top: 2rem;
      height: 3rem;
      width: 3rem;
    }

    #navigation-arrows .arrow {
      stroke: lightblue;
      /*stroke-width: 0.8em; Chrome behaves differently with ems here */
      stroke-width: 16px;
      stroke-linecap: round;
      fill: none;
      cursor: pointer;
    }

    td,
    th {
      padding: 0.2em 0.8em;
    }

    th {
      text-align: start;
    }
  </style>
  <script>
    let presenterWindow;
    let activeSlide;
    let slideCount;

    const arrowUp = document.querySelector('.arrow.up');
    const arrowDown = document.querySelector('.arrow.down');
    const arrowRight = document.querySelector('.arrow.right');
    const arrowLeft = document.querySelector('.arrow.left');
    arrowUp.addEventListener('click',
      () => {activateSlideSafe(activeSlide[0], activeSlide[1] - 1);}
    );
    arrowDown.addEventListener('click',
      () => {activateSlideSafe(activeSlide[0], activeSlide[1] + 1);}
    );
    arrowLeft.addEventListener('click',
      () => {activateSlideSafe(activeSlide[0] - 1, 1);}
    );
    arrowRight.addEventListener('click',
      () => {activateSlideSafe(activeSlide[0] + 1, 1);}
    )
    const init = () => {
      slideCount = countSlides();
      activateSlideSafe(1, 1);
      addKeyControls();
      addSwipeControls();
    }

    // count slides
    const countSlides = () => {
      const counts = [];
      return [...document.querySelectorAll('.section')].map(section => section.childNodes.length);
    }

    const updateVisible = () => {
      for (let section of document.querySelectorAll('.section')) {
        if (section.id === `section-${activeSlide[0]}`) {
          section.className = 'section active';
        } else {
          section.className = 'section inactive';
        }
      }
      for (let slide of document.querySelectorAll('.slide')) {
        if (slide.id === `slide-${activeSlide[0]}-${activeSlide[1]}`) {
          slide.className = 'slide active';
        } else {
          slide.className = 'slide inactive';
        }
      }
    }

    const updatePageArrows = () => {
      if (slideCount.length === 1) {
        arrowLeft.style.opacity = "0";
        arrowRight.style.opacity = "0";
      } else {
        const progressSections = (activeSlide[0] - 1) / (slideCount.length - 1);
        arrowLeft.style.opacity = progressSections.toString();
        arrowRight.style.opacity = (1 - progressSections).toString();
      }
      const slidesInActiveSection = slideCount[activeSlide[0] - 1]
      if (slidesInActiveSection === 1) {
        arrowUp.style.opacity = "0";
        arrowDown.style.opacity = "0";
      } else {
        const progressSlides = (activeSlide[1] - 1) / (slidesInActiveSection - 1);
        arrowUp.style.opacity = progressSlides.toString();
        arrowDown.style.opacity = (1 - progressSlides).toString();
      }
    }

    /**
     * Activate a slide if it exists, else do nothing
    */
    const activateSlideSafe = (sectionIndex, slideIndex) => {
      if (1 <= sectionIndex && sectionIndex <= slideCount.length && 1 <= slideIndex && slideIndex <= slideCount[sectionIndex - 1]) {
        activeSlide = [sectionIndex, slideIndex];
        updateVisible();
        updatePageArrows();
        scrolltoActiveSlide();
      }
    }

    const activateSlideNextSafe = () => {
      if (activeSlide[1] === slideCount[activeSlide[0] - 1]) {
        activateSlideSafe(activeSlide[0] + 1, 1);
      } else {
        activateSlideSafe(activeSlide[0], activeSlide[1] + 1);
      }
    }

    const activateSlideRightSafe = () => {
      activateSlideSafe(activeSlide[0] + 1, 1);
    }

    const activateSlideLeftSafe = () => {
      activateSlideSafe(activeSlide[0] - 1, 1);
    }

    const activateSlideDownSafe = () => {
      activateSlideSafe(activeSlide[0], activeSlide[1] + 1);
    }

    const activateSlideUpSafe = () => {
      activateSlideSafe(activeSlide[0], activeSlide[1] - 1);
    }

    const scrolltoActiveSlide = () => {
      const slideId = `#slide-${activeSlide[0]}-${activeSlide[1]}`;
      if (presenterWindow) {
        const activeSlide = presenterWindow.document.querySelector(slideId);
        if (activeSlide) {
          activeSlide.scrollIntoView();
        }
      }
    }

    const addKeyControls = () => {
      document.querySelector('body').addEventListener('keydown', event => {
        if (event.key === 'p') {
          const canvasContent = document.querySelector('#canvas-content').innerHTML;
          presenterWindow = window.open(document.URL, '_blank');
          presenterWindow.onload = () => {
            presenterWindow.document.querySelector('body').innerHTML = canvasContent;
          }
        }
        if (event.key === 'ArrowRight') {
          activateSlideRightSafe();
        } else if (event.key === 'ArrowLeft') {
          activateSlideLeftSafe();
        } else if (event.key === 'ArrowDown') {
          activateSlideDownSafe();
        } else if (event.key === 'ArrowUp') {
          activateSlideUpSafe();
        } else if (event.key === 'Enter') {
          activateSlideNextSafe();
        }
      });
    }

    const addSwipeControls = () => {

      const distance = 100;

      let startPos;
      let handled;

      document.addEventListener('touchstart', event => {
        startPos = event.touches[0];
        handled = false;
      });

      document.addEventListener('touchmove', event => {
        if (!handled) {
          let currentPos = event.touches[0];
          const xDiff = currentPos.clientX - startPos.clientX;
          const yDiff = currentPos.clientY - startPos.clientY;
          if (Math.abs(xDiff) > 2*Math.abs(yDiff) ||
              Math.abs(yDiff) > 2*Math.abs(xDiff)) {
            if (xDiff > distance) {
              activateSlideLeftSafe();
              handled = true;
            } else if (xDiff < -distance) {
              activateSlideRightSafe();
              handled = true;
            } else if (yDiff > distance) {
              activateSlideUpSafe();
              handled = true;
            } else if (yDiff < -distance) {
              activateSlideDownSafe();
              handled = true;
            }
          }
        }
      });
    }

    init();

  </script>
</body>

</html>