

  
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  
  
    <section><h1>React</h1></section>
    <section><h2>Präsentation und Code</h2><p>Präsentationen verfügbar unter: <a href="https://karuga.eu/courses-presentations">https://karuga.eu/courses-presentations</a></p><p>Code verfügbar unter: <a href="https://github.com/marko-knoebl/courses-code">https://github.com/marko-knoebl/courses-code</a></p></section>
<section><h2>Ihr Trainer</h2><p>Marko Knöbl</p><ul>
<li>Frontend Web-Entwicklung<ul>
<li>JavaScript</li>
<li>React, Angular</li>
</ul></li>
<li>Programmierung<ul>
<li>Python, JavaScript</li>
</ul></li>
</ul></section>
<section><h2>Vorstellung der Teilnehmer</h2><ul>
<li>Aktuelle Projekte</li>
<li>Vorkenntnisse</li>
<li>Erwartungen / Wünsche</li>
</ul></section>
<section><h2>Organisatorisches</h2><ul>
<li>Kursdauer</li>
<li>Pausen</li>
<li>Mittagessen</li>
<li>Unterlagen</li>
<li>Fragen, Feedback? - Jederzeit erwünscht</li>
</ul></section>
    <section><h1>Agenda</h1><section><h2>Agenda</h2><section><h3>Einstieg</h3><ul>
<li>Kurzüberblick über React</li>
<li>Modernes JS / JS-Grundlagen für React</li>
<li>Deklaratives Rendering / Arbeiten mit application-state</li>
<li>Komponenten</li>
<li>Einbinden vordefinierter Komponenten</li>
</ul></section></section><section><h2>Agenda</h2><section><h3>Vertiefung</h3><ul>
<li>Lifecycle</li>
<li>Routing</li>
<li>Testen von Komponenten</li>
<li>Redux</li>
<li>Progressive Web Apps mit React</li>
</ul></section></section></section>
    <section><h1>React.js</h1><section><h2>Was ist React?</h2><ul>
<li>Eine der 3 großen JavaScript-UI-Libraries (neben Angular, vue.js)</li>
</ul></section><section><h2>Grundlagen moderner JavaScript-UI-Libraries</h2><ul>
<li>Deklarativ</li>
<li>Komponenten-Struktur</li>
</ul></section><section><h2>Deklarativ</h2><ul>
<li>Im Hintergrund steht ein Datenmodell, das den gesamten Anwendungszustand abbildet</li>
<li>Man ändert das Modell, das View wird von alleine (möglichst effizient) aktualisiert</li>
</ul></section><section><h2>Komponenten-Struktur</h2><ul>
<li>"eigene" HTML-Tags</li>
<li>Datenfluss via Properties und Events</li>
<li>Üblicherweise unidirektionaler Datenfluss (vom Eltern- zum Kindelement)</li>
</ul></section><section><h2>Beispiel: Datenmodell und -fluss in einer Todo-App</h2></section><section><h2>Was macht React besonders?</h2><ul>
<li>JavaScript-basierte Template-Syntax</li>
<li>Explizite Änderung des Anwendungszustands mittels Settern</li>
</ul></section><section><h2>Geschichte von React</h2><ul>
<li>Ab 2011 intern bei Facebook in Verwendung</li>
<li>Open Source seit 2013</li>
<li>Aktuelle Major Version: React 16 (September 2017)</li>
<li>Februar 2019: Einführung von Hooks</li>
</ul></section></section>
    <section><h1>Create-React-App</h1><section><h2>Entwicklung mit node.js und npm</h2><ul>
<li>node.js: JS-Runtime<ul>
<li>Ausführen des lokalen Enwicklungsservers</li>
<li>Unit-Tests</li>
</ul></li>
<li>npm: Paketmanager<ul>
<li>zum Verwalten von Abhängigkeiten</li>
<li>Pakete im <em>node_modules</em>-Ordner</li>
<li>Konfiguration in <em>package.json</em></li>
</ul></li>
</ul></section><section><h2>create-react-app</h2><p>Meistgenutzte Methode zum Erstellen von React-Anwendungen</p><p>ausführen via:</p><pre><code class="language-bash">npx create-react-app playground
</code></pre><p>siehe auch: <a href="https://reactjs.org/docs/add-react-to-a-new-app.html">https://reactjs.org/docs/add-react-to-a-new-app.html</a></p></section><section><h2>create-react-app</h2><p>Erstellt eine einfache React-Anwendung, auf deren Basis weiter gearbeitet werden kann</p><p>Viele Aspekte sind vorkonfiguriert:</p><ul>
<li>lokaler Entwicklungsserver</li>
<li>Unittest-Framework jest</li>
<li>Webpack und Babel</li>
<li>SCSS und CSS Module</li>
</ul></section><section><h2>Standard Projektstruktur</h2><ul>
<li><code>public/index.html</code>, <code>src/index.js</code>: Einstiegspunkte</li>
<li><code>App.js</code>, <code>App.css</code>: Definieren App-Komponente</li>
<li><code>node_modules</code>: Abhängigkeiten</li>
</ul></section><section><h2>Entwicklungsserver und Build</h2><p>Im Projektordner:</p><ul>
<li><code>npm start</code>: Startet den lokalen Entwicklungsserver</li>
<li><code>npm run build</code>: Erstellt einen Build (zum Deployen auf einem Webserver)</li>
</ul></section></section>
    <section><h1>React &#x26; JSX Grundlagen</h1><section><h2>Definieren einer Komponente als Funktion</h2><pre><code class="language-jsx">import React from 'react';

const App = () => {
  return &#x3C;div>Hello, World!&#x3C;/div>;
};

export default App;
</code></pre></section><section><h2>Definieren einer Komponente als Klasse</h2><pre><code class="language-jsx">import React, { Component } from 'react';

class App extends Component {
  render() {
    return &#x3C;div>Hello, World!&#x3C;/div>;
  }
}

export default App;
</code></pre></section><section><h2>Komponentendefinition</h2><p>Um sie von normalen Tags zu unterscheiden, beginnen Komponentennamen immer mit einem Großbuchstaben</p></section><section><h2>JSX: JS + XML</h2><p>JSX = Templatesprache von React</p><ul>
<li><strong>&#x3C;</strong> wechselt von JS zu XML/HTML</li>
<li><strong>{</strong> wechselt zurück zu JS</li>
</ul></section><section><h2>JSX: JS + XML</h2><pre><code class="language-jsx">&#x3C;div>Ein Jahr hat {365 * 24} Stunden&#x3C;/div>
</code></pre></section><section><h2>JSX: Aufgaben</h2><ul>
<li>Zeige das aktuelle Datum an</li>
<li>Zeige zufällig entweder den Text "Kopf" oder "Zahl" in einem div an</li>
</ul></section><section><h2>JSX: Properties</h2><p>Der Wechsel von XML auf JS klappt auch bei Properties:</p><pre><code class="language-jsx">&#x3C;a href={'https://en.wikipedia.org/wiki/' + articleName}>
  some article
&#x3C;/a>
</code></pre><p>Beachte die fehlenden Anführungszeichen bei href</p></section><section><h2>JSX Properties: Aufgabe</h2><p>Zeige ein Bild basierend auf einer ID an. Verwende dazu:</p><pre><code class="language-js">const getImgUrl = id =>
  'https://picsum.photos/200?image=' + id.toString();
</code></pre></section><section><h2>JSX: events</h2><pre><code class="language-jsx">const hello = () => {...}

&#x3C;button onClick={hello}>Say Hello&#x3C;/button>
</code></pre><p>Liste von Browser-Events:<br />
<a href="https://www.w3schools.com/jsref/dom_obj_event.asp">https://www.w3schools.com/jsref/dom_obj_event.asp</a></p></section><section><h2>State Beispiel</h2><p>(wir widmen uns dem Thema <em>State</em> später im Detail)</p><pre><code class="language-jsx">const Counter = () => {
  const [count, setCount] = useState(0);

  return (
    &#x3C;button
      onClick={() => {
        setCount(count + 1);
      }}>
      {count}
    &#x3C;/button>
  );
};
</code></pre></section></section>
    <section><h1>VS Code</h1><section><h2>VS Code</h2><p><a href="https://code.visualstudio.com">https://code.visualstudio.com</a></p><p>Open-Source-Entwicklungsumgebung</p><p>Unabhängig vom eigentlichen Visual Studio</p></section><section><h2>VS Code: Ordner öffnen</h2><p>ganzen Ordner öffnen mit <em>File</em> - <em>Open Folder</em></p></section><section><h2>VS Code: Datei-Explorer, Split Editor</h2></section><section><h2>VS Code: Terminal</h2><p>Öffnen und Schließen der Ansicht via <em>Strg</em> + <em>Ö</em></p><p>zusätzliches Terminal via Symbol <em>+</em></p><p>übernimmt das aktuell geöffnete Verzeichnis</p></section><section><h2>VS Code - Konfiguration</h2><p>Via <em>File - Preferences - Settings</em></p><p>Eingeteilt in <em>User Settings</em> und <em>Workspace Settings</em></p></section><section><h2>VS Code - Konfigurationsmöglichkeiten</h2><p>Empfehlungen:</p><ul>
<li>Accept Suggestion on Commit Character (Autovervollständigung ohne <em>Enter</em>): <em>deaktivieren</em></li>
<li>Tab Size: <em>2</em> oder <em>4</em></li>
</ul><p>Weitere Möglichkeiten:</p><ul>
<li>Auto Save</li>
<li>Format on Save</li>
<li>Word Wrap</li>
<li>EOL</li>
<li>Workbench: Color Theme</li>
</ul></section><section><h2>VS Code - Befehle</h2><p><em>F1</em> oder <em>Ctrl</em> + <em>Shift</em> + <em>P</em>: Befehlspalette</p><ul>
<li>durchsuchbar</li>
<li>zeigt Kurzbefehle an</li>
</ul><p>Beispiele für Befehle:</p><ul>
<li><em>Search a string in the file</em></li>
<li><em>Search: Find in Files</em></li>
<li><em>Format Document</em></li>
<li><em>Toggle line comment</em> / <em>Toggle block comment</em></li>
<li><em>Go to definition</em> / <em>Peek definition</em> (nur für bestimmte Dateitypen)</li>
<li><em>Rename symbol</em> (nur für bestimmte Dateitypen)</li>
</ul></section><section><h2>VS Code - Tastenkürzel</h2><ul>
<li><em>Ctrl</em> + <em>F2</em>: Mehrere Textcursor setzen</li>
<li><em>Alt</em> + Mausklick: Mehrere Textcursor setzen</li>
</ul></section></section>
    <section><h1>Prettier</h1><section><h2>Prettier</h2><p><a href="https://prettier.io/">https://prettier.io/</a></p><ul>
<li>Code-Formatierung nach strikten Regeln</li>
<li>VS-Code-Plugin (via Alt + Shift + F)</li>
</ul></section><section><h2>Prettier-Konfiguration</h2><p>in VS Code: über Datei - Einstellungen - Einstellungen</p><p>oder über <code>.prettierrc.json</code>:</p><pre><code class="language-json">{
  "bracketSpacing": false,
  "singleQuote": true,
  "trailingComma": true,
  "jsxBracketSameLine": true
}
</code></pre></section></section>
    <section><h1>ESLint</h1><section><h2>ESLint</h2><p>Linter für JavaScript (und TypeScript)</p><p>VS Code Plugin verfügbar</p></section></section>
    <section><h1>ES2015+</h1><section><h2>Modernes JavaScript</h2></section><section><h2>JavaScript-Standardisierung</h2><p>JavaScript wird unter dem Namen <em>ECMAScript</em> (kurz ES) standardisiert</p></section><section><h2>JavaScript: Versionen</h2><ul>
<li>Von allen Browsern unterstützt: ES5 (2009 veröffentlicht)</li>
<li>Nächste große Version: <em>ES2015</em> (oder ES6)</li>
<li>Seither: jährliche kleinere Änderungen (aktuell: ES2018)</li>
</ul></section><section><h2>JavaScript: Versionsunterstützung</h2><ul>
<li>Übersicht: siehe <a href="http://kangax.github.io/compat-table/es6/">http://kangax.github.io/compat-table/es6/</a></li>
<li>In der Praxis: Modernes JavaScript wird in ES5 transpiliert (mittels Babel, webpack)</li>
</ul></section><section><h2>Wichtige Neuerungen in ES2015</h2></section><section><h2>Module &#x26; Imports</h2><ul>
<li>Möglichkeit, Funktionalität aus anderen js-Dateien zu importieren – kein globaler Namespace mehr</li>
<li>Benötigt einen Bundler, z.B. webpack</li>
</ul><pre><code class="language-js">// user.js
export class User {
  ...
}
</code></pre><pre><code class="language-js">// main.js
import { User } from 'user.js';
</code></pre></section><section><h2>Module &#x26; Imports</h2><pre><code class="language-js">// User.js
// es kann 1 default export geben
export default class User {
   ...
}
</code></pre><pre><code class="language-js">// main.js
import User from 'User.js';
</code></pre></section><section><h2>Imports in webpack</h2><p>Bundler wie webpack können beim Importieren vom JavaScript Standard abweichen:</p><ul>
<li>Dateiendungen wie <code>.js</code> können optional sein</li>
<li>wenn der Import auf einen Ordner verweist, sucht webpack nach einer <code>index.js</code> Datei in diesem Ordner</li>
</ul></section><section><h2>let</h2><ul>
<li>Neue Alternative zu var – mit leicht anderem Scoping</li>
<li>Scope: umgebende geschweifte Klammern (statt umgebender Funktion)</li>
</ul><pre><code class="language-js">if (true) {
  let a = 3;
}
console.log(a); // ReferenceError
</code></pre></section><section><h2>const</h2><p>Deklariert eine Variable, die nicht mehr neu zugewiesen werden kann.<br />
Das bezeichnete Objekt selbst kann allerdings modifiziert werden</p><pre><code class="language-js">const names = ['Alice', 'Bob', 'Claire'];
names = ['Andrew', 'Bob', 'Claire']; // ungültig!
names[0] = 'Andrew'; // gültig
</code></pre></section><section><h2>Destrukturierende Zuweisung</h2><pre><code class="language-js">let a = 1;
let b = 2;
[a, b] = [b, a];

const [result, errors] = someComputation();
</code></pre></section><section><h2>Destrukturierende Zuweisung</h2><pre><code class="language-js">const person = { name: 'John', age: 48 };

const { name, age } = person;
</code></pre></section><section><h2>Pfeilfunktionen</h2><ul>
<li>Kurzschreibweise für anonyme Funktionen</li>
<li>Lässt <em>this</em> unverändert (überschreibt es nicht)</li>
</ul><pre><code class="language-js">let multiply = (a, b) => {
  return a * b;
};

let multiply = (a, b) => a * b;
</code></pre></section><section><h2>Pfeilfunktionen</h2><p>wenn es genau einen Parameter gibt: Parameterklammern optional</p><pre><code class="language-js">const square = a => a * a;
</code></pre><p>wenn direkt ein Objekt zurückgegeben werden soll: mit runden Klammern umschießen</p><pre><code class="language-js">const getState = () => ({
  loggedIn: true,
  userName: 'mike',
});
</code></pre></section><section><h2>Klassen</h2><p>Ersetzen die alten Konstruktorfunktionen und Prototypen</p></section><section><h2>Klassen</h2><pre><code class="language-js">class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  hello() {
    return `My name is ${this.firstName}`;
  }
}
</code></pre></section><section><h2>Klassen und Vererbung</h2><pre><code class="language-js">class User extends Person {
  constructor(firstName, lastName, userName) {
    // ruft Person.constructor auf
    super(firstName, lastName);
    this.userName = userName;
  }
}
</code></pre></section><section><h2>Array-Iteration (for ... of)</h2><p>Über die Einträge in einem Array iterieren:</p><pre><code class="language-js">let names = ['Anna', 'Bernhard', 'Caro'];
for (let name of names) {
  console.log(name);
}
</code></pre></section><section><h2>Spread Syntax (Arrays und Objekte)</h2><pre><code class="language-js">let squares = [1, 4, 9];
let moreSquares = [...squares, 16, 25];
// moreSquares: [1, 4, 9, 16, 25]
</code></pre><pre><code class="language-js">let person = { firstName: 'Joe', lastName: 'Doe', age: 31 };
let newPerson = { ...person, email: 'j@d.com', age: 32 };
// {firstName: 'Joe', lastName: 'Doe', email: 'j@d.com', age: 32}
</code></pre></section><section><h2>Template-Strings</h2><ul>
<li>Neue Syntax zum <em>Erstellen</em> von Strings</li>
<li>Werden mit Backticks begrenzt</li>
<li>Erlauben mehrzeilige Strings und Interpolation:</li>
</ul><pre><code class="language-js">let name = 'Anton';
let greeting = `Hallo, ${name}!
                Das ist ES2015!`;
</code></pre></section><section><h2>Standardparameter in Funktionen</h2><p>In Funktionen können nun Standardparameter definiert werden:</p><pre><code class="language-js">let join = (strings, separator='') => {
  ...
}
</code></pre></section></section>
    <section><h1>this - quirks</h1><section><h2>this - quirks</h2><p>In Objektmethoden bezieht sich <code>this</code> üblicherweise auf das aktuelle Objekt</p><p><strong>allerdings</strong>:</p><ul>
<li>jeder Funktionsaufruf setzt <em>this</em> neu (nicht nur Methodenaufrufe)</li>
<li><em>this</em> wird nur richtig gesetzt, wenn die Methode mit der Syntax <code>object.method()</code> aufgerufen wird</li>
</ul></section><section><h2>Problem: <em>this</em> in anonymen Funktionen</h2><pre><code class="language-js">class myComponent {
  constructor() {
    // this ist hier richtig gesetzt
    this.foo = true;
    setTimeout(function() {
      //this wird hier überschrieben (auf window)
      console.log(this.foo);
    }, 1000);
  }
}
</code></pre></section><section><h2>Lösung: <em>Pfeilfunktionen</em></h2><pre><code class="language-js">class myComponent {
  constructor() {
    // this ist hier richtig gesetzt
    this.foo = true;
    setTimeout(() => {
      // this wird hier *nicht* überschrieben
      console.log(this.foo);
    }, 1000);
  }
}
</code></pre></section><section><h2>Problem: Methodenaufrufe ohne Methodensyntax</h2><pre><code class="language-js">class Foo {
  constructor() {
    this.message = 'hello';
  }
  greet() {
    console.log(this.message);
  }
}
let foo = new Foo();
foo.greet(); // klappt
let fg = foo.greet;
fg(); // klappt nicht (this ist undefined)
</code></pre></section><section><h2>Lösung: Pfeil-Methoden</h2><p>Seit ES2018 einsetzbar:</p><pre><code class="language-js">class Foo {
  constructor() {
    this.message = 'hello';
  }
  greet = () => {
    console.log(this.message);
  };
}
</code></pre></section><section><h2>Lösung: Binden von Methoden</h2><pre><code class="language-js">let f = new Foo();
f.greet(); // klappt
let fg = f.greet.bind(f);
fg(); // klappt jetzt auch
</code></pre><p>Üblicherweise Zuweisung im constructor:</p><pre><code class="language-js">  constructor() {
    this.greet = this.greet.bind(this);
  }
</code></pre></section></section>
    <section><h1>State (Komponentenzustand)</h1><section><h2>State</h2><p>React Komponenten können einen internen Zustand (<em>state</em>) haben</p><p>Auf den state kann im Template verwiesen werden. Damit ändert sich die Anzeige automatisch, wenn Teile des States neu gesetzt werden.</p></section><section><h2>State in funktionalen Komponenten</h2><p>In funktionalen Komponenten verwenden wir den Hook <code>useState</code>:</p><pre><code class="language-js">import { useState } from 'react';
</code></pre></section><section><h2>State in funktionalen Komponenten</h2><p>Die Funktion <code>useState</code> kann zu Beginn der Komponentenfunktion (wiederholt) aufgerufen werden. Sie hat die folgende Signatur:</p><ul>
<li>sie nimmt einen Parameter entgegen - den initialen Zustand</li>
<li>sie gibt bei jedem Aufruf ein Array mit zwei Einträgen zurück: Den aktuellen Zustand sowie eine Funktion, mit der der Zustand neu gesetzt werden kann</li>
</ul><pre><code class="language-js">const App = () => {
  const [count, setCount] = useState(0);
  const [title, setTitle] = useState('React app');

  return ...
};
</code></pre></section><section><h2>Beispiel: Counter</h2><p>Wir fügen unserer Anwendung einen Button hinzu. Zu Beginn zeigt dieser den Wert 0. Bei jedem Klick erhöht er sich um 1.</p></section><section><h2>Beispiel: Counter</h2><pre><code class="language-jsx">const App = () => {
  const [count, setCount] = useState(0);

  return (
    &#x3C;button
      onClick={() => {
        setCount(count + 1);
      }}>
      {count}
    &#x3C;/button>
  );
};
</code></pre></section><section><h2>Beispiel: Counter</h2><p>Aufgabe: füge zur Anwendung von eben einen <em>Reset</em>-Knopf hinzu</p></section><section><h2>Beispiel: Slideshow</h2><p>Slideshow, die Bilder wie das folgende anzeigt:</p><p><code>https://picsum.photos/200?image=10</code></p><ul>
<li>Buttons für <em>vorwärts</em> und <em>zurück</em></li>
<li>Button für <em>zurück zum Start</em></li>
<li>Verhindern, dass ins negative gezählt wird</li>
</ul></section><section><h2>State in Klassenkomponenten</h2><p>In Klassenkomponenten repräsentiert <code>this.state</code> den Zustand.</p><p><code>this.state</code> ist immer ein JavaScript-Objekt mit verschiedenen Einträgen (Properties)</p><p>Zustandsänderungen erfolgen über <code>this.setState()</code></p></section><section><h2>Struktur von this.state</h2><p><em>this.state</em> ist ein JavaScript-Objekt:</p><pre><code class="language-js">constructor() {
  [...]
  this.state = {
    loggedIn: true,
    todos: ['laundry', 'groceries', 'taxes'],
  }
}
</code></pre></section><section><h2>Änderung von this.state</h2><p>via <code>this.setState()</code></p><pre><code class="language-js">this.setState({ loggedIn: false });
</code></pre><p>setState überschreibt alle angegebenen Einträge im state-Objekt</p></section><section><h2>Wiederholtes Aufrufen von this.setState</h2><p>Rat: in einem Event-Handler nur 1x <code>setState</code> aufrufen.</p><p>Wenn doch mehrere Aufrufe von <code>setState</code> erfolgen und ein Aufruf auf der vorhergehenden Zustandsänderung basiert:</p><pre><code class="language-js">this.setState(oldState => ({ count: oldState.count + 1 }));
this.setState(oldState => ({ count: oldState.count + 1 }));
</code></pre><p>Wir übergeben setState eine Funktion, die den alten in den neuen Zustand überführt.</p></section></section>
    <section><h1>Inputs</h1><section><h2>Inputs</h2><p>Besonderheit von input-Elementen:</p><p>Ihre Properties (insbesondere <code>.value</code>) können durch User-Interaktionen direkt geändert werden</p><p>Es gibt damit Aspekte des UI-Zustands, die nicht im state erfasst sind.</p></section><section><h2>Inputs</h2><p>So können wir den Value eines Inputs im State erfassen:</p><pre><code class="language-jsx">&#x3C;input
  value={inputText}
  onChange={event => {
    setInputText(event.target.value);
  }}
/>
</code></pre></section></section>
    <section><h1>Entwicklerwerkzeuge für React</h1><section><h2>React Developer Tools</h2><ul>
<li><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">Chrome Plugin</a></li>
<li><a href="https://addons.mozilla.org/de/firefox/addon/react-devtools/">Firefox Plugin</a></li>
</ul><p>Features:</p><ul>
<li>Anzeige der Komponentenstruktur</li>
<li>Anzeige von State und Props</li>
<li>Ändern von State und Props</li>
<li>Performanceanalyse des Renderings von Komponenten</li>
</ul></section><section><h2>Debugging in VS Code</h2><p>Extensions:</p><ul>
<li><strong>Debugger for Chrome</strong></li>
<li>Debugger for Firefox</li>
</ul></section><section><h2>Debugging in VS Code: Konfiguration</h2><p>Konfigurationsdatei erstellen: In der Debugger-Sidebar auf das Zahnradsymbol (<em>Configure or fix 'launch.json'</em>)</p><p>in <em>launch.json</em>:</p><pre><code class="language-json">{
  "type": "chrome",
  "request": "launch",
  "name": "Launch Chrome for React",
  "url": "http://localhost:3000"
}
</code></pre></section><section><h2>Debugging in VS Code: starten</h2><p>Testserver muss im Hintergrund schon laufen</p><p>Debugging in VS Code starten: mittels <em>F5</em></p></section></section>
    <section><h1>map, filter, reduce</h1><section><h3>Array-Methoden für die funktionale Programmierung</h3></section><section><h2>map</h2><ul>
<li>Ändert jeden Eintrag eines Arrays mit Hilfe einer Funktion ab</li>
<li>Rückgabewert: neues Array</li>
</ul><pre><code class="language-js">let myNumbers = [2, 10, 23];

let triple = n => 3 * n;

let newNumbers = myNumbers.map(triple);
// [6, 30, 69]
</code></pre></section><section><h2>filter</h2><ul>
<li>Behält nur gewisse Einträge in einem Array</li>
<li>Nutzt eine Funktion, um Einträge auf ein bestimmtes Kriterium zu testen</li>
<li>Rückgabewert: neues Array</li>
</ul><pre><code class="language-js">let myNumbers = [2, 10, 23];

let isEven = n => n % 2 === 0;

let newNumbers = myNumbers.filter(isEven);
// [2, 10]
</code></pre></section><section><h2>reduce</h2><ul>
<li>Verarbeitet die Einträge in einem Array zu einem einzelnen Wert</li>
<li>Verwendet eine Funktion, die aus zwei bestehenden Werten einen resultierenden Wert erstellt - diese Funktion wird wiederholt aufgerufen</li>
</ul></section><section><h2>reduce - Beispiel</h2><pre><code class="language-js">let transactions = [
  { amount: -56, title: 'groceries' },
  { amount: +1020, title: 'salary' },
  { amount: -13, title: 'dinner' },
  { amount: -96, title: 'electricity' },
];
let initialBalance = 317;

let reducer = (aggregator, transaction) =>
  aggregator + transaction.amount;

let currentBalance = transactions.reduce(
  reducer,
  initialBalance
);

// 317 -> 261 -> 1281 -> 1268 -> 1172
</code></pre></section></section>
    <section><h1>JSX im Detail</h1><section><h2>JSX: Elemente wiederholen</h2><p>Grundsätzlich können wir über Arrays mehrere Elemente einbinden:</p><pre><code class="language-xml">&#x3C;ul>
  { [
    &#x3C;li>1&#x3C;/li>,
    &#x3C;li>2&#x3C;/li>
  ] }
&#x3C;/ul>
</code></pre></section><section><h2>JSX: Elemente wiederholen</h2><p>Meist verwenden wir zum wiederholen die <code>.map()</code> - Methode</p><pre><code class="language-jsx">const todos = [
  { id: 1, title: 'groceries', completed: false },
  { id: 2, title: 'cooking', completed: true },
  { id: 3, title: 'gardening', completed: false },
];

&#x3C;ul>
  {todos.map(todo => (
    &#x3C;li>{todo.title}&#x3C;/li>
  ))}
&#x3C;/ul>
</code></pre></section><section><h2>JSX: Elemente wiederholen</h2><p>Bei obigem Code:<br />
Warnung in der Browser-Konsole (Wegen Effizienz)<br />
Lösung: <strong>key</strong>:</p><pre><code class="language-jsx">&#x3C;ul>
  {todos.map(todo => (
    &#x3C;li key={todo.id}>{todo.title}&#x3C;/li>
  ))}
&#x3C;/ul>
</code></pre></section><section><h2>JSX: if / else</h2><pre><code class="language-jsx">&#x3C;div>{Math.random() > 0.5 ? 'heads' : 'tails'}&#x3C;/div>
</code></pre></section><section><h2>JSX: if / else</h2><pre><code class="language-jsx">let face;
if (Math.random() > 0.5) {
  face = 'heads';
} else {
  face = 'tails';
}

return &#x3C;div>{face}&#x3C;/div>;
</code></pre></section><section><h2>JSX: if</h2><pre><code class="language-jsx">&#x3C;div>{state.hasError &#x26;&#x26; state.errorMessage}&#x3C;/div>
</code></pre></section><section><h2>Whitespace</h2><p>in HTML sind die folgenden Beispiele äquivalent (und enthalten je ein Leerzeichen zwischen den Bildern):</p><pre><code class="language-html">&#x3C;img src="foo.png"> &#x3C;img src="bar.png">
</code></pre><pre><code class="language-html">&#x3C;img src="foo.png">    &#x3C;img src="bar.png">
</code></pre><pre><code class="language-html">&#x3C;img src="foo.png">
&#x3C;img src="bar.png">
</code></pre></section><section><h2>Whitespace</h2><p>in JSX gilt:</p><ul>
<li>Whitespace zwischen Elementen innerhalb einer Zeile wird als einzelnes Leerzeichen interpretiert</li>
<li>Whitespace zwischen Elementen, der über mehrere Zeilen geht, wird ignoriert</li>
</ul><p>Einzelnes Leerzeichen:</p><pre><code class="language-xml">&#x3C;img src="foo.png" />     &#x3C;img src="bar.png" />
</code></pre><p>Kein Leerzeichen:</p><pre><code class="language-xml">&#x3C;img src="foo.png" />
&#x3C;img src="bar.png" />
</code></pre></section><section><h2>Whitespace</h2><p>"Erzwungenes" Einfügen eines Leerzeichens in JSX:</p><pre><code class="language-xml">&#x3C;img src="foo.png" />{" "}
&#x3C;img src="bar.png" />
</code></pre></section><section><h2>Kommentare</h2><p>Kommentare können als JavaScript-Kommentare geschrieben werden:</p><pre><code class="language-jsx">a = &#x3C;div>Hello World!{/*this is a comment*/}&#x3C;/div>;
</code></pre></section><section><h2>Fragmente</h2><p>Erlauben es einer Komponente, mehrere Elemente zurückzugeben (anstatt eines einzelnen Elements)</p><pre><code class="language-jsx">return (
  &#x3C;>
    &#x3C;td>Hello&#x3C;/td>
    &#x3C;td>World&#x3C;/td>
  &#x3C;/>
);
</code></pre></section><section><h2>JSX Kompilierung</h2><pre><code class="language-jsx">const element = &#x3C;a href="https://google.com">Google&#x3C;/a>;
</code></pre><p>wird kompiliert zu:</p><pre><code class="language-js">const element = React.createElement(
  'a',
  { href: 'https://google.com' },
  'Google'
);
</code></pre></section></section>
    <section><h1>Styling in JSX</h1><section><h2>JSX: CSS-Klassen</h2><pre><code class="language-jsx">&#x3C;div className={getClassName()}>[...]&#x3C;/div>
</code></pre></section><section><h2>CSS-Module</h2><p>Bei create-react-app sind CSS-Module vorkonfiguriert. Diese erlauben das Verwenden von CSS-Klassennamen, die garantiert über CSS-Dateien hinweg eindeutig sind.</p><pre><code class="language-js">import styles from './TodoItem.module.css';

&#x3C;div className={styles.todoItem}>...&#x3C;/div>;

&#x3C;div className={`${styles.todoItem} ${styles.completed}`}>
  ...
&#x3C;/div>;
</code></pre></section><section><h2>SCSS einbinden</h2><pre><code class="language-bash">npm install node-sass
</code></pre><pre><code class="language-js">import styles from './TodoItem.module.scss';
</code></pre><pre><code class="language-scss">/* TodoItem.module.scss */
@import '../colors';
...
</code></pre><pre><code class="language-scss">/* colors.scss */
$primary: lightblue;
</code></pre></section><section><h2>JSX: Dynamische Stile</h2><pre><code class="language-jsx">&#x3C;div
  style={{
    color: '#333',
    fontSize: getFontSize(),
  }}
/>
</code></pre></section></section>
    <section><h1>Props</h1><section><h2>State &#x26; Props</h2><ul>
<li>State = interner Zustand einer Komponente</li>
<li>Props = vom Elternelement übergebene Parameter</li>
</ul></section><section><h2>Props in eigenen Komponenten</h2><p>Beispiel:</p><pre><code class="language-jsx">&#x3C;Rating stars={3} />
</code></pre></section><section><h2>Props in Funktionskomponenten</h2><p>Beispiel (einfach):</p><pre><code class="language-jsx">const Rating = props => (
  &#x3C;div className="rating">{'*'.repeat(props.stars)}&#x3C;/div>
);
</code></pre><p>oder</p><pre><code class="language-jsx">const Rating = ({ stars }) => (
  &#x3C;div className="rating">{'*'.repeat(stars)}&#x3C;/div>
);
</code></pre></section><section><h2>Props in Klassenkomponenten</h2><p>example:</p><pre><code class="language-jsx">import React, { Component } from 'react';

export class Rating extends Component {
  render() {
    return (
      &#x3C;div className="rating">
        {'*'.repeat(this.props.stars)}
      &#x3C;/div>
    );
  }
}
</code></pre></section><section><h2>props.children</h2><p>Über <code>props.children</code> können Inhalte an eine Komponente übergeben werden</p><p>Beispiel: <code>Bordered</code>-Komponente:</p><pre><code class="language-jsx">&#x3C;Bordered>lorem ipsum&#x3C;/Bordered>
</code></pre><p>Definition der Komponente:</p><pre><code class="language-jsx">const Bordered = props => (
  &#x3C;div class="bordered">{props.children}&#x3C;/div>
);
</code></pre></section></section>
    <section><h1>Eigene Events</h1><section><h2>Datenfluss</h2><ul>
<li>parent → child: props</li>
<li>child → parent: events</li>
</ul></section><section><h2>Eigene Events</h2><p>Eventhandler werden als Funktionen definiert und via props übergeben / erhalten.</p></section><section><h2>Eigene Events</h2><p>Beispiel <code>ToggleButton</code>: Button, der entweder "off" oder "on" anzeigt:</p><p>Prop: <code>active</code> - kann auf <code>true</code> bzw <code>false</code> gesetzt sein<br />
Event: <code>onToggle</code> - Funktion, die mit dem neuen Zustand aufgerufen wird</p><pre><code class="language-jsx">&#x3C;button
  onClick={() => {
    props.onToggle(!props.active);
  }}>
  {props.active ? 'on' : 'off'}
&#x3C;/button>
</code></pre></section><section><h2>Eigene Events</h2><p>Beispiel <code>ToggleButton</code>: Der Button muss passend eingebunden werden</p><pre><code class="language-jsx">const [myOption, setMyOption] = useState(true);

&#x3C;ToggleButton
  active={myOption}
  onToggle={newIsActive => {
    setMyOption(newIsActive);
  }}
/>;
</code></pre></section><section><h2>Eigene Events</h2><p>Beispiele:</p><ul>
<li>Rating-Komponente mit anklickbaren Sternen</li>
<li>NumberInput-Komponente zum Angeben einer Ganzzahl mit +/- buttons<ul>
<li>Bonus: Umsetzung des APIs, sodass es kompatibel zu normalen input-Elementen ist und input-Elemente leicht durch NumberInput-Komponeneten ersetzt werden können</li>
<li>Bonus: zusätzliche min / max - Property bei der Komponente</li>
</ul></li>
</ul></section></section>
    <section><h1>Komponentenlibraries</h1><section><h2>Komponentenlibraries</h2><ul>
<li>Material UI: React-Komponenten im <em>Material Design</em></li>
<li>React Native &#x26; React Native Web: React components &#x26; framework for mobile &#x26; web apps</li>
<li>React Bootstrap</li>
<li>Blueprint</li>
<li>...</li>
</ul></section><section><h2>Material-UI</h2><p>Vorgefertigte React-Komponenten im Material-Design-Stil (Stil von Google/Android)</p></section><section><h2>Material-UI: Installation und Verwendung</h2><p><a href="https://material-ui.com">https://material-ui.com</a></p><p>siehe Info-Boxen zu <em>Installation</em> und <em>Usage</em></p></section><section><h2>Material-UI: Übungen</h2><ul>
<li>Button</li>
<li>Todo App im Material Style</li>
</ul></section></section>
    <section><h1>Übungen</h1><section><h2>Übungen</h2><p>Liste an verfügbaren React-Komponenten: <a href="https://github.com/brillout/awesome-react-components">awesome-react-components</a></p><p>Aufgabe: "Nachbau" einer der Komponenten</p><p>Beispiele:</p><ul>
<li>bar chart</li>
<li>color picker</li>
<li>table / data grid</li>
<li>tabs</li>
</ul></section></section>
    <section><h1>Typechecker für React</h1><section><h2>Typechecker für React</h2><p>Insbesondere was das Interface von Komponenten angeht, ist es sehr sinvoll, vorhandene Properties und Events anzugeben</p><p>Möglichkeiten:</p><ul>
<li>Library <code>prop-types</code></li>
<li>Verwendung von <code>TypeScript</code> als Sprache</li>
</ul></section><section><h2>prop-types</h2><p>Beispiel:</p><pre><code class="language-js">import PropTypes from 'prop-types';

// definition of Rating component here

Rating.propTypes = {
  stars: PropTypes.number.isRequired,
  onStarsChange: PropTypes.func,
};
</code></pre></section><section><h2>prop-types in VS Code</h2><p>Plugin: <em>React PropTypes IntelliSense</em></p></section><section><h2>React mit TypeScript</h2><p>neues Projekt:</p><pre><code class="language-bash">npx create-react-app my-app --typescript
</code></pre></section><section><h2>Komponenten mit TypeScript (Funktionen)</h2><pre><code class="language-tsx">type TodoListProps = {
  todos: Array&#x3C;TodoType>;
  onToggle: (id: number) => void;
  onDelete: (id: number) => void;
};

const TodoList = (props: TodoListProps) => {
  const [filterText, setFilterText] = useState&#x3C;string>('');

  return &#x3C;div>...&#x3C;/div>;
};
</code></pre></section><section><h2>Komponenten mit TypeScript (Klassen)</h2><pre><code class="language-tsx">// TodoList.tsx
type TodoItemProps = {
  todo: TodoType;
  onToggle: (id: int) => void;
};
type TodoItemState = {};
</code></pre><pre><code class="language-tsx">class TodoItem extends React.PureComponent&#x3C;
  TodoItemProps,
  TodoItemState
> {}
</code></pre></section><section><h2>Eventtypen</h2><ul>
<li><code>React.FormEvent</code></li>
<li><code>React.FormEvent&#x3C;HTMLFormElement></code></li>
<li><code>React.ChangeEvent&#x3C;HTMLInputElement></code></li>
<li><code>React.MouseEvent&#x3C;HTMLDivElement></code></li>
</ul></section></section>
    <section><h1>TypeScript</h1><section><h2>TypeScript</h2><p>= Obermenge von JavaScript mit Erweiterungen:</p><ul>
<li><strong>Statische Typisierung</strong></li>
<li>Public / Private Properties</li>
<li>Decorators</li>
</ul></section><section><h2>Statische Typisierung</h2><p>Datentypen können angegeben werden und unterstützen insbesondere die Entwicklungsumgebung:</p><ul>
<li>Autovervollständigung</li>
<li>Fehlermeldungen bei nicht passenden Datentypen</li>
</ul></section><section><h2>Statische Typisierung</h2><p>Beim build: TypeScript wird in JavaScript übersetzt, alle Typeninformationen gehen dabei verloren</p></section><section><h2>Typsystem: Variablen</h2><pre><code class="language-ts">let age: number = 32;
let name: string = 'Andreas';
</code></pre></section><section><h2>Typsystem: Arrays</h2><pre><code class="language-js">let names: Array&#x3C;string> = ['Anna', 'Bernhard'];
</code></pre><p>alternative Schreibweise:</p><pre><code class="language-ts">let names: string[] = ['Anna', 'Bernhard'];
</code></pre></section><section><h2>Typsystem: Funktionen</h2><pre><code class="language-ts">function repeatString(
  text: string,
  times: number
): string {
  return ...
}
</code></pre><pre><code class="language-ts">const repeatString = (
  text: string,
  times: number
): string => {
  return ...;
};
</code></pre></section><section><h2>Typsystem: void</h2><p>Void: umfasst <em>undefined</em> und <em>null</em> - hauptsächlich genutzt für Funktionen, die nichts zurückgeben</p><pre><code class="language-ts">const warnUser = (): void => {
  alert('warning!');
};
</code></pre></section><section><h2>Typsystem: any</h2><p>Any: lässt alle Typen zu</p><pre><code class="language-ts">let myInput: any = document.getElementById('myinput');
console.log(myInput.value);
</code></pre></section><section><h2>Typsystem: Type assertions</h2><pre><code class="language-ts">(window as any).myGlobalVariable = 'foo';
</code></pre></section><section><h2>Typsystem: Types &#x26; Interfaces</h2><p>Interfaces: beschreiben die Struktur eines Objekts / einer Klasse genauer<br />
z.B.: <code>TodoInterface</code>, <code>PersonInterface</code></p><p>Types: Ähnlich wie Interfaces, aber auch auf Strings, Arrays, ... anwendbar</p><p>Types bieten im wesentlichen mehr Funktionalität als Interfaces</p><p><a href="https://stackoverflow.com/a/52682220/">https://stackoverflow.com/a/52682220/</a></p></section><section><h2>Typsystem: Types</h2><pre><code class="language-ts">type TodoType = {
  id: number;
  title: string;
  completed: boolean;
};

type TodoCollection = Array&#x3C;TodoType>;
</code></pre></section><section><h2>Types bei Objekten</h2><pre><code class="language-ts">type TodoType = {
  id: number;
  title: string;
  completed: boolean;
  // optional
  description?: string;
  // Methode
  toggle: (id: number) => void;
};
</code></pre></section><section><h2>Types bei Objekten</h2><pre><code class="language-ts">class AdvancedTodo implements TodoType {
  ...
}
</code></pre></section><section><h2>Intersection Types</h2><p>Mittels <code>&#x26;</code>:</p><pre><code class="language-ts">type x = a &#x26; b;
</code></pre><p>Der Intersection Typ <code>x</code> kann gegenüber <code>a</code>:</p><ul>
<li>Werte von existierenden Properties weiter einschränken</li>
<li>zusätzliche verpflichtende Properties hinzufügen</li>
</ul></section><section><h2>Intersection Types: Konkretisierung von Typen</h2><pre><code class="language-ts">type Action = {
  type: string;
  payload?: object;
};

type AddTodoAction = Action &#x26; {
  type: 'ADD_TODO';
  payload: {
    title: string;
  };
};
</code></pre></section><section><h2>Intersection Types: Kombinieren von Typen</h2><pre><code class="language-ts">type Serializable = {
  serialize: () => string;
};

type SerializableAction = Action &#x26; Serializable;
</code></pre><p>Objekte, die den Typ <code>SerializableAction</code> implementieren, müssen sowohl alle Einträge aus <code>Serializable</code> als auch aus <code>Action</code> implementieren.</p></section><section><h2>Union Types</h2><p>Der Typ <code>x</code> muss entweder alle Kriterien von <code>a</code> erfüllen oder alle Kriterien von <code>b</code> erfüllen.</p><pre><code class="language-ts">type x = a | b;
</code></pre><p>Alternative Schreibweise über mehrere Zeilen:</p><pre><code class="language-ts">type TodoActionType =
  | AddTodoActionType
  | ToggleTodoActionType;
</code></pre></section><section><h2>Generics</h2><p>Allgemeine Typendeklaration, zu der bei der Anwendung nähere Informationen spezifiziert werden können (via <code>&#x3C;...></code>)</p></section><section><h2>Generics</h2><p>Beispiel: <code>Array</code> ist ein Generic</p><pre><code class="language-ts">let a: Array&#x3C;number> = [1, 2, 3];
let b: Array&#x3C;string> = ['one', 'two', 'three'];
</code></pre><p>Beispiel: Reacts <code>Component</code> ist ein Generic</p><pre><code class="language-ts">class MyComp extends Component&#x3C;MyProps, MyState> {
  ...
}
</code></pre></section><section><h2>Private &#x26; Public Properties</h2><pre><code class="language-ts">class Clock {
  private formatTime(time) {
    return ...
  }
  public start() {
    ...
  }
}
</code></pre></section><section><h2>Typendeklarationen für Libraries</h2><p>Einige JavaScript Libraries beinhalten auch Typendeklarationen für TypeScript - z.B. <em>react</em>, <em>redux</em>.</p><p>Für andere Libraries gibt es meist externe Deklarationen mit dem Präfix <em>@types/</em>, z.B. für <em>react-redux</em> existiert das Paket <em>@types/react-redux</em>.</p></section></section>
  

