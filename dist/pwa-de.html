<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Progressive Web Apps</title>
  <style>/*

Original highlight.js style (c) Ivan Sagalaev <maniac@softwaremaniacs.org>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #F0F0F0;
}


/* Base color: saturation 0; */

.hljs,
.hljs-subst {
  color: #444;
}

.hljs-comment {
  color: #888888;
}

.hljs-keyword,
.hljs-attribute,
.hljs-selector-tag,
.hljs-meta-keyword,
.hljs-doctag,
.hljs-name {
  font-weight: bold;
}


/* User color: hue: 0 */

.hljs-type,
.hljs-string,
.hljs-number,
.hljs-selector-id,
.hljs-selector-class,
.hljs-quote,
.hljs-template-tag,
.hljs-deletion {
  color: #880000;
}

.hljs-title,
.hljs-section {
  color: #880000;
  font-weight: bold;
}

.hljs-regexp,
.hljs-symbol,
.hljs-variable,
.hljs-template-variable,
.hljs-link,
.hljs-selector-attr,
.hljs-selector-pseudo {
  color: #BC6060;
}


/* Language color: hue: 90; */

.hljs-literal {
  color: #78A960;
}

.hljs-built_in,
.hljs-bullet,
.hljs-code,
.hljs-addition {
  color: #397300;
}


/* Meta color: hue: 200 */

.hljs-meta {
  color: #1f7199;
}

.hljs-meta-string {
  color: #4d99bf;
}


/* Misc effects */

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}
</style>
</head>

<body>
  <div id="canvas">
    <div id="canvas-content">

      <section class="section" id="section-1"><section class="slide" id="slide-1-1">
        <h1 id="title">Progressive Web Apps</h1>

      </section><section class="slide" id="slide-1-2">
        <h2 id="präsentation-und-code">Präsentation und Code</h2>
<p>Präsentationen verfügbar unter: <a href="https://karuga.eu/courses-presentations">https://karuga.eu/courses-presentations</a></p>
<p>Code verfügbar unter: <a href="https://github.com/marko-knoebl/courses-code">https://github.com/marko-knoebl/courses-code</a></p>

      </section><section class="slide" id="slide-1-3">
        <h2 id="ihr-trainer">Ihr Trainer</h2>
<p>Marko Knöbl</p>
<ul>
<li>Frontend Web-Entwicklung<ul>
<li>JavaScript</li>
<li>React, Angular</li>
</ul>
</li>
<li>Programmierung<ul>
<li>Python, JavaScript</li>
</ul>
</li>
</ul>

      </section><section class="slide" id="slide-1-4">
        <h2 id="vorstellung-der-teilnehmer">Vorstellung der Teilnehmer</h2>
<ul>
<li>Name</li>
<li>Firma</li>
<li>Aktuelle Projekte</li>
<li>Grund der Schulung</li>
<li>Vorkenntnisse</li>
<li>Erwartungen / Wünsche</li>
</ul>

      </section><section class="slide" id="slide-1-5">
        <h2 id="organisatorisches">Organisatorisches</h2>
<ul>
<li>Kursdauer</li>
<li>Pausen</li>
<li>Mittagessen</li>
<li>Unterlagen</li>
<li>Fragen, Feedback? - Jederzeit erwünscht</li>
</ul>

      </section></section><section class="section" id="section-2"><section class="slide" id="slide-2-1">
        <h1 id="agenda">Agenda</h1>

      </section><section class="slide" id="slide-2-2">
        <h2 id="agenda---grundlagen">Agenda - Grundlagen</h2>
<ul>
<li>VS Code, Chrome Developer Tools</li>
<li>modern JavaScript</li>
<li>Promises</li>
<li>Web Worker</li>
</ul>

      </section><section class="slide" id="slide-2-3">
        <h2 id="agenda">Agenda</h2>
<ul>
<li>Webmanifest-Datei</li>
<li>Service Worker<ul>
<li>Workbox</li>
<li>Service Worker schreiben</li>
</ul>
</li>
<li>Datenspeicher<ul>
<li>localStorage</li>
<li>indexedDB</li>
</ul>
</li>
<li>Benachrichtigungen und Push-Benachrichtigungen</li>
</ul>

      </section></section><section class="section" id="section-3"><section class="slide" id="slide-3-1">
        <h1 id="grundlagen-zum-kurs">Grundlagen zum Kurs</h1>

      </section><section class="slide" id="slide-3-2">
        <h2 id="grundlagen-zum-kurs-am-beispiel-einer-todo-app">Grundlagen zum Kurs (am Beispiel einer Todo-App)</h2>
<ul>
<li>Arbeiten mit VS Code &amp; Chrome<ul>
<li>Prettier</li>
<li>Chrome Dev Tools</li>
</ul>
</li>
<li>ES2015+<ul>
<li>Module</li>
<li>Pfeilfunktionen</li>
<li>const &amp; let</li>
</ul>
</li>
<li>einen lokalen Entwicklungsserver starten</li>
</ul>

      </section><section class="slide" id="slide-3-3">
        <h2 id="lokaler-entwicklungsserver">lokaler Entwicklungsserver</h2>
<p>npm-Paket <code>http-server</code></p>
<pre><code class="language-bash">npm install -g http-server
http-server</code></pre>

      </section></section><section class="section" id="section-4"><section class="slide" id="slide-4-1">
        <h1 id="vs-code">VS Code</h1>

      </section><section class="slide" id="slide-4-2">
        <h2 id="vs-code">VS Code</h2>
<p><a href="https://code.visualstudio.com">https://code.visualstudio.com</a></p>
<ul>
<li>Open-Source-Entwicklungsumgebung</li>
<li>Unabhängig vom eigentlichen Visual Studio</li>
</ul>

      </section><section class="slide" id="slide-4-3">
        <h2 id="vs-code-ordner-öffnen">VS Code: Ordner öffnen</h2>
<p>ganzen Ordner öffnen mit <em>File</em> - <em>Open Folder</em></p>

      </section><section class="slide" id="slide-4-4">
        <h2 id="vs-code-speichern">VS Code: speichern</h2>
<p>Nicht gespeicherte Dateien sind durch einen Kreis statt des &quot;X&quot; im Tab erkennbar</p>
<p>Speichern mit <em>Strg</em> + <em>S</em></p>
<p>oder: <em>File</em> - <em>Auto Save</em></p>

      </section><section class="slide" id="slide-4-5">
        <h2 id="vs-code-datei-explorer-split-editor">VS Code: Datei-Explorer, Split Editor</h2>

      </section><section class="slide" id="slide-4-6">
        <h2 id="vs-code-terminal">VS Code: Terminal</h2>
<p>Öffnen und Schließen der Ansicht via <em>Strg</em> + <em>Ö</em></p>
<p>zusätzliches Terminal via Symbol <em>+</em></p>
<p>übernimmt das aktuell geöffnete Verzeichnis</p>

      </section><section class="slide" id="slide-4-7">
        <h2 id="vs-code---konfiguration">VS Code - Konfiguration</h2>
<p>Via <em>File - Preferences - Settings</em></p>
<p>Eingeteilt in <em>User Settings</em> und <em>Workspace Settings</em></p>

      </section><section class="slide" id="slide-4-8">
        <h2 id="vs-code---konfigurationsmöglichkeiten">VS Code - Konfigurationsmöglichkeiten</h2>
<p>Empfehlungen:</p>
<ul>
<li>Auto Save: <em>aktivieren</em></li>
<li>Accept Suggestion on Commit Character (Autovervollständigung ohne <em>Enter</em>): <em>deaktivieren</em></li>
<li>Tab Size: <em>2</em></li>
</ul>
<p>Weitere Möglichkeiten:</p>
<ul>
<li>Format on Save</li>
<li>Format on Paste</li>
<li>EOL</li>
<li>Workbench: Color Theme</li>
</ul>

      </section><section class="slide" id="slide-4-9">
        <h2 id="vs-code---kurzbefehle">VS Code - Kurzbefehle</h2>
<ul>
<li><em>Strg</em> + <em>F</em>: Suchen in Datei</li>
<li><em>Alt</em> + <em>Shift</em> + <em>F</em>: Formatieren der Datei</li>
<li><em>Ctrl</em> + <em>#</em>: aus- / einkommentieren</li>
<li><em>F2</em>: Umbenennen von Variablen</li>
<li><em>Alt</em> + Mausklick: Mehrere Textcursor zum gleichzeitigen Schreiben setzen</li>
</ul>

      </section></section><section class="section" id="section-5"><section class="slide" id="slide-5-1">
        <h1 id="pwa-grundlagen">PWA Grundlagen</h1>
<!-- https://developers.google.com/web/ilt/pwa/ -->


      </section><section class="slide" id="slide-5-2">
        <h2 id="pwa-grundlagen">PWA Grundlagen</h2>
<p><a href="https://developers.google.com/web/ilt/pwa/why-build-pwa">https://developers.google.com/web/ilt/pwa/why-build-pwa</a></p>
<ul>
<li>Brücke zwischen Web und Apps</li>
<li>Im Browser, am Desktop und Mobil</li>
<li>Web-Apps, die sich ganz wie native Apps anfühlen:<ul>
<li>Dauerhafte Installation und Offline-Nutzung (service workers)</li>
<li>Lokale Speicherung von Anwendungsdaten (localstorage, indexedDB)</li>
<li>Scheint wie andere Apps im Menü auf (web-manifest)</li>
<li>Benachrichtigungen am Gerät darstellen (service workers)</li>
</ul>
</li>
</ul>
<!-- google-präsentation bis S. 23 -->


      </section><section class="slide" id="slide-5-3">
        <h2 id="browser-unterstützung">Browser-Unterstützung</h2>
<p>Service worker:</p>
<p><a href="https://caniuse.com/#search=service%20workers">https://caniuse.com/#search=service%20workers</a></p>
<p>Web app manifest:</p>
<p><a href="https://caniuse.com/#search=manifest">https://caniuse.com/#search=manifest</a></p>
<p>indexedDB:</p>
<p><a href="https://caniuse.com/#search=indexeddb">https://caniuse.com/#search=indexeddb</a></p>

      </section><section class="slide" id="slide-5-4">
        <h2 id="beispiele">Beispiele</h2>
<ul>
<li><a href="https://pwa.rocks">https://pwa.rocks</a><ul>
<li>wiki offline</li>
<li>telegram</li>
<li>paper planes</li>
</ul>
</li>
</ul>

      </section><section class="slide" id="slide-5-5">
        <h2 id="chrome-audit">Chrome audit</h2>
<p>Entwicklerwerkzeuge - audits</p>

      </section></section><section class="section" id="section-6"><section class="slide" id="slide-6-1">
        <h1 id="service-worker-gundlagen">Service Worker Gundlagen</h1>

      </section><section class="slide" id="slide-6-2">
        <h2 id="service-worker---motivation">Service Worker - Motivation</h2>
<p>Service Worker sind ein Kernelement von PWAs. Sie dienen als lokaler Proxy zwischen dem Web Browser und dem Server.</p>
<p>Haupteinsatzgebiet: Offlinenutzung / schnellere Nutzung von Web Apps (Ersatz für die veraltete AppCache-Funktion)</p>

      </section><section class="slide" id="slide-6-3">
        <h2 id="service-worker---nutzungsbeispiele">Service Worker - Nutzungsbeispiele</h2>
<ul>
<li><em>Spiel</em>: Beim ersten Laden werden alle benötigten Resourcen heruntergeladen und stehen forthin offline zur Verfügung</li>
<li><em>Chat-Anwendung</em>: Die Avatare aller Freunde werden in einem Cache abgelegt; sie werden täglich aktualisiert</li>
<li><em>Wikipedia-Anwendung</em>: Die letzten 30 besuchten Artikel werden gecacht</li>
<li><em>Nachrichten-Anwendung</em>: Die Startseite mit Artikeln soll gecacht werden und beim Öffnen sofort verfügbar sein; Danach wird sie sofern möglich aktualisiert</li>
</ul>

      </section><section class="slide" id="slide-6-4">
        <h2 id="service-worker">Service Worker</h2>
<h3 id="traditionelle-web-app">Traditionelle Web-App:</h3>
<p>Endgerät ⟺ Web Server</p>
<h3 id="pwa">PWA:</h3>
<p>Endgerät ⟺ Service Worker ⟺ Web Server</p>

      </section><section class="slide" id="slide-6-5">
        <h2 id="service-worker---grundlagen">Service Worker - Grundlagen</h2>
<p>service worker = Skript, das im Hintergrund läuft</p>
<p>Funktionen:</p>
<ul>
<li>Caching von Resourcen</li>
<li>Sync im Hintergrund</li>
<li>Push-Benachrichtigungen (auch wenn Browser / Anwendung geschlossen)</li>
</ul>

      </section><section class="slide" id="slide-6-6">
        <h2 id="service-worker---registrierung">Service Worker - Registrierung</h2>
<p>Wir rufen <code>.register()</code> auf und übergeben den Pfad des Service Worker Skripts</p>
<pre><code class="language-js"><span class="hljs-comment">// main.js</span>
navigator.serviceWorker.register(<span class="hljs-string">'./serviceWorker.js'</span>);</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// serviceWorker.js</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this is the service worker'</span>);</code></pre>

      </section><section class="slide" id="slide-6-7">
        <h2 id="service-worker">Service Worker</h2>
<p>Service worker in den Browser Tools betrachten:</p>
<p>in Chrome: Dev Tools unter <em>Application</em> - <em>Service Workers</em></p>
<p>in Firefox: unter <code>about:debugging#workers</code></p>

      </section></section><section class="section" id="section-7"><section class="slide" id="slide-7-1">
        <h1 id="service-worker-mit-workbox">Service Worker mit Workbox</h1>

      </section><section class="slide" id="slide-7-2">
        <h2 id="service-worker-mit-workbox">Service Worker mit Workbox</h2>
<p><strong>Workbox</strong> = Library, die das Schreiben von Serviceworkern erleichtert</p>
<p><a href="https://developers.google.com/web/tools/workbox/">https://developers.google.com/web/tools/workbox/</a></p>

      </section><section class="slide" id="slide-7-3">
        <h2 id="workbox-beispiel">Workbox Beispiel</h2>
<p>Einbinden eines Service Workers der Antworten cacht und sie als Fallback verwendet, falls Resourcen nicht verfügbar sind:</p>
<pre><code class="language-js"><span class="hljs-comment">// service-worker.js</span>
importScripts(
  <span class="hljs-string">'https://storage.googleapis.com/'</span> +
    <span class="hljs-string">'workbox-cdn/releases/4.1.1/workbox-sw.js'</span>
);

workbox.routing.registerRoute(
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'.*'</span>),
  <span class="hljs-keyword">new</span> workbox.strategies.NetworkFirst()
);</code></pre>

      </section><section class="slide" id="slide-7-4">
        <h2 id="workbox-beispiel">Workbox Beispiel</h2>
<p>Wir können die Auswirkungen der Verwendung von Service Workern in den Chrome Developer Tools unter <em>Application/Service Workers</em> und <em>Application/Cache Storage</em> begutachten</p>

      </section></section><section class="section" id="section-8"><section class="slide" id="slide-8-1">
        <h1 id="web-app-manifest">Web App Manifest</h1>

      </section><section class="slide" id="slide-8-2">
        <h2 id="web-app-manifest">Web App Manifest</h2>
<p>Das web app manifest ist eine json Datei, die Informationen zu einer Webanwendung beinhaltet.</p>
<p>Durch Bereitstellung einer manifest Datei kann die Installation einer PWA ermöglicht werden.</p>

      </section><section class="slide" id="slide-8-3">
        <h2 id="manifest-datei">Manifest-Datei</h2>
<p>einbinden via:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"manifest"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"manifest.json"</span> /&gt;</span></code></pre>

      </section><section class="slide" id="slide-8-4">
        <h2 id="manifest-datei">Manifest-Datei</h2>
<pre><code class="language-json">{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Todo"</span>,
  <span class="hljs-attr">"short_name"</span>: <span class="hljs-string">"Todo"</span>,
  <span class="hljs-attr">"start_url"</span>: <span class="hljs-string">"."</span>,
  <span class="hljs-attr">"display"</span>: <span class="hljs-string">"standalone"</span>,
  <span class="hljs-attr">"icons"</span>: [
    {
      <span class="hljs-attr">"src"</span>: <span class="hljs-string">"images/icon-32.png"</span>,
      <span class="hljs-attr">"sizes"</span>: <span class="hljs-string">"32x32"</span>,
      <span class="hljs-attr">"type"</span>: <span class="hljs-string">"image/png"</span>
    },
    ...
  ]
}</code></pre>

      </section><section class="slide" id="slide-8-5">
        <h2 id="manifest-datei-einträge">Manifest-Datei: Einträge</h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/Manifest">https://developer.mozilla.org/en-US/docs/Web/Manifest</a></p>

      </section><section class="slide" id="slide-8-6">
        <h2 id="manifest-datei-einräge">Manifest-Datei: Einräge</h2>
<p>essentielle Einträge in Chrome:</p>
<ul>
<li><code>name</code></li>
<li><code>short_name</code></li>
<li><code>start_url</code></li>
<li><code>icons</code> - verwendet im Menü, im Splash Screen; für Chrome sollten icons der folgenden Größen bereitgestellt werden: <code>144</code>, <code>192</code>, <code>512</code></li>
<li><code>display</code>: <code>fullscreen</code> / <code>standalone</code> / <code>minimal-ui</code> / <code>browser</code></li>
</ul>

      </section><section class="slide" id="slide-8-7">
        <h2 id="manifest-datei-einträge">Manifest-Datei: Einträge</h2>
<ul>
<li><code>background_color</code> - sollte die gleiche Farbe sein wie die CSS-Hintergrundfarbe der Anwendung</li>
<li><code>description</code></li>
<li><code>orientation</code>:<ul>
<li><code>any</code></li>
<li><code>natural</code></li>
<li><code>landscape</code> (<code>landscape-primary</code>, <code>landscape-secondary</code>)</li>
<li><code>portrait</code> (<code>portrait-primary</code>,
<code>portrait-secondary</code>)</li>
</ul>
</li>
<li><code>theme_color</code></li>
</ul>

      </section><section class="slide" id="slide-8-8">
        <h2 id="meta-tags-in-html">Meta tags in HTML</h2>
<p>Diese Mata Tags sind hilfreich:</p>
<ul>
<li>in Chrome: Android Fensterfarbe: <code>&lt;meta name=&quot;theme-color&quot; content=&quot;...&quot; /&gt;</code> - das sollte das gleiche sein wie <code>theme_color</code> in der Manifest-Datei</li>
<li>in iOS: <code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;</code> - versteckt das Browser UI</li>
</ul>

      </section></section><section class="section" id="section-9"><section class="slide" id="slide-9-1">
        <h1 id="app-installation">App-Installation</h1>

      </section><section class="slide" id="slide-9-2">
        <h2 id="app-installation">App-Installation</h2>
<p>Browser können die Möglichkeit bieten, für PWAs Einträge zum Startmenü / zum Homescreen hinzuzufügen</p>

      </section><section class="slide" id="slide-9-3">
        <h2 id="app-installation-unter-chrome-und-ios">App-Installation unter Chrome und iOS</h2>
<p>Unter iOS können Benutzer einen Shortcut zu jeder Website zum Menü hinzufügen. Für PWAs funktioniert das auf die gleiche Art.</p>
<p>Bei Chrome können PWAs den Benutzer zur Installation auffordern. Installierte PWAs verhalten sich anders als Webseiten - z.B. erscheinen sie in einem seperaten Fenster.</p>

      </section><section class="slide" id="slide-9-4">
        <h2 id="app-installation">App-Installation</h2>
<p>für Chrome:</p>
<p><a href="https://developers.google.com/web/fundamentals/app-install-banners/">https://developers.google.com/web/fundamentals/app-install-banners/</a></p>

      </section><section class="slide" id="slide-9-5">
        <h2 id="app-installation">App-Installation</h2>
<p>Voraussetzung, um den App-Installations-Dialog anzuzeigen:</p>
<ul>
<li>Manifest-Datei beinhaltet:<ul>
<li><em>short_name</em> oder <em>name</em></li>
<li>Icons der Größen 192px und 512px</li>
<li><em>start_url</em></li>
<li><em>display</em> ist entweder <em>fullscreen</em>, <em>standalone</em> oder <em>minimal-ui</em></li>
</ul>
</li>
<li>HTTPS aktiv</li>
<li>es gibt einen aktiven Service Worker (mit einem fetch Event handler)</li>
<li>Benutzer hat mit der Domain zumindest 30 Sekunden interagiert</li>
</ul>

      </section><section class="slide" id="slide-9-6">
        <h2 id="app-installation">App-Installation</h2>
<p>Sobald alle Voraussetzungen erfüllt sind, wird das <code>beforeinstallprompt</code> Event ausgelöst; Wir können dieses Event abfangen und für später speichern</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> installPromptEvent;

<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'beforeinstallprompt'</span>, event =&gt; {
  <span class="hljs-comment">// the browser is ready to show the install prompt</span>
  event.preventDefault();
  installPromptEvent = event;
  showInstallBtn();
});</code></pre>

      </section><section class="slide" id="slide-9-7">
        <h2 id="app-installation">App-Installation</h2>
<p>Sobald der Benutzer die Anwendung installieren möchte können wir das gespeicherte Event verwenden:</p>
<pre><code class="language-js">installBtn.addEventListener(<span class="hljs-string">'click'</span>, () =&gt; {
  hideInstallBtn();
  <span class="hljs-comment">// Show the prompt</span>
  installPromptEvent.prompt();
});</code></pre>

      </section><section class="slide" id="slide-9-8">
        <h2 id="deployment">Deployment</h2>
<p>Deployment z.B. auf <a href="https://app.netlify.com/drop">https://app.netlify.com/drop</a></p>
<p>Wichtig: Aufrufen über HTTPS</p>

      </section></section><section class="section" id="section-10"><section class="slide" id="slide-10-1">
        <h1 id="service-worker">Service worker</h1>

      </section><section class="slide" id="slide-10-2">
        <h2 id="service-worker">Service worker</h2>
<p>Service worker sind client-seitige Proxies zwischen Webbrowser und Server.</p>
<p>Service worker können Resourcen cachen und sie entweder aus dem Netzwerk oder dem internen Cache abrufen.</p>

      </section><section class="slide" id="slide-10-3">
        <h2 id="service-worker">Service worker</h2>
<p>Es läuft zu jeder Domain / registrierten URL genau ein ServiceWorker</p>
<p>Service worker sind besondere Web-Worker, daher:</p>
<ul>
<li>kein direkter Zugriff auf das DOM</li>
<li>Kommunikation mit Hauptthread mittels postMessage</li>
</ul>

      </section><section class="slide" id="slide-10-4">
        <h2 id="browser-unterstützung">Browser Unterstützung</h2>
<p><a href="https://caniuse.com/##feat=serviceworkers">caniuse</a></p>
<p>Serviceworker werden unterstützt =&gt; ES2015 wird unterstützt</p>

      </section><section class="slide" id="slide-10-5">
        <h2 id="verwandthe-technologien">Verwandthe Technologien</h2>
<ul>
<li>fetch (Netzwerkanfragen senden)</li>
<li>cache (Netzwerkanfragen cachen)</li>
</ul>

      </section></section><section class="section" id="section-11"><section class="slide" id="slide-11-1">
        <h1 id="promises--fetch">Promises &amp; Fetch</h1>
<!-- siehe auch: webdev/fetch -->
<!-- https://developers.google.com/web/fundamentals/primers/promises -->


      </section><section class="slide" id="slide-11-2">
        <h2 id="promises--fetch">Promises &amp; Fetch</h2>
<p><em>Promises</em>: eine Möglichkeit, um asynchronen Code in JavaScript auszuführen</p>
<p><em>Fetch</em>: moderne Möglichkeit, Netzwerkanfragen mit JavaScript zu versenden, basiert auf Promises</p>

      </section><section class="slide" id="slide-11-3">
        <h2 id="promises---grundlagen">Promises - Grundlagen</h2>
<p>Werden verwendet, um einmalige Events zu behandeln</p>
<p>Erlauben dem Browser, auf ein Event zu <em>warten</em> - zb auf eine Antwort aus dem Netzwerk oder Daten aus der Datenbank</p>
<p>Das Warten ist <em>non-blocking</em>, damit kann anderer Code währenddessen ausgeführt werden</p>

      </section><section class="slide" id="slide-11-4">
        <h2 id="promises-vs-callbacks">Promises vs Callbacks</h2>
<p>Promises sind eine Alternative zu Callbacks; Sie lösen das gleiche Problem mit einem etwas anderen Ansatz.</p>
<p>Beispiel: Funktion <code>getTodos</code>, die Todo-Daten von einem Server lädt und sie an <code>logTodos</code> übergibt</p>
<pre><code class="language-js"><span class="hljs-comment">// callback</span>
getTodos(logTodos);</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// promise</span>
getTodos().then(logTodos);</code></pre>

      </section><section class="slide" id="slide-11-5">
        <h2 id="promises-vs-callbacks">Promises vs Callbacks</h2>
<p>Ein Vorteil von Promises gegenüber Callbacks ist, dass Promises leicht verkettet werden können:</p>
<pre><code class="language-js">getTodos()
  .then(parseJSON)
  .then(transformDataFormat)
  .then(logTodos);</code></pre>

      </section><section class="slide" id="slide-11-6">
        <h2 id="promises-beispiel-fetch-einer-website">Promises Beispiel: Fetch einer Website</h2>
<pre><code class="language-js"><span class="hljs-comment">// dieser Code kann zu jeder Website in der</span>
<span class="hljs-comment">// Browser-Konsole ausgeführt werden</span>
<span class="hljs-keyword">const</span> url = <span class="hljs-string">'/'</span>;

<span class="hljs-comment">// eine Anfrage auf die Homepage einer Website starten</span>
fetch(url)
  <span class="hljs-comment">// auf die Antwort warten, dann den Textinhalt der</span>
  <span class="hljs-comment">// Antwort auslesen</span>
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.text())
  <span class="hljs-comment">// auf den Textinhalt warten, dann loggen</span>
  .then(<span class="hljs-built_in">console</span>.log);</code></pre>

      </section><section class="slide" id="slide-11-7">
        <h2 id="fetch-einer-website-erklärung">Fetch einer Website: Erklärung</h2>
<p>Das Abfragen einer URL und das Auslesen des Antworttexts können länger dauern.</p>
<p>Mit <code>.then()</code> warten wir jeweils auf das Resultat.</p>
<p>Die Funktion <code>.then()</code> bekommt einen Handler (in Form einer anderen Funktion) übergeben.</p>
<p>Das Resultat des ersten Handlers (<code>response =&gt; response.text()</code>) ist wiederum ein neues Promise.</p>
<p>Der zweite Handler (<code>console.log</code>) loggt das Resultat einfach.</p>

      </section><section class="slide" id="slide-11-8">
        <h2 id="beispiel-landesflagge">Beispiel: Landesflagge</h2>
<pre><code class="language-js"><span class="hljs-comment">// ohne Promises</span>
getImageName(country, name =&gt;
  fetchFlag(name, flagResponse =&gt;
    processFlag(flagResponse, appendFlag)
  )
);</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// mit Promises</span>
getImageName(country)
  .then(fetchFlag)
  .then(processFlag)
  .then(appendFlag);</code></pre>

      </section><section class="slide" id="slide-11-9">
        <h2 id="fehlerbehandlung">Fehlerbehandlung</h2>
<p>Fehler können mit <code>.catch()</code> behandelt werden</p>
<pre><code class="language-js"><span class="hljs-keyword">return</span> getImageName(country)
  .catch(getFallbackName)
  .then(fetchFlag)
  .then(processFlag)
  .then(appendFlag)
  .catch(logError);</code></pre>

      </section><section class="slide" id="slide-11-10">
        <h2 id="todo-app-fetch---grundlegend">Todo App: fetch - grundlegend</h2>
<pre><code class="language-js">fetch(<span class="hljs-string">'https://jsonplaceholder.typicode.com/todos'</span>)
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
  .then(updatePageWithNewTodos);
  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error when getting todos'</span>);
  })</code></pre>

      </section><section class="slide" id="slide-11-11">
        <h2 id="nutzung-mit-async--await-moderne-browser">Nutzung mit async / await (moderne Browser)</h2>
<pre><code class="language-js"><span class="hljs-keyword">const</span> url = <span class="hljs-string">'https://jsonplaceholder.typicode.com/todos'</span>;

<span class="hljs-keyword">const</span> fetchAsync = <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(url);
  <span class="hljs-keyword">let</span> todos = <span class="hljs-keyword">await</span> response.json();
  displayTodos(todos);
};

fetchAsync();</code></pre>

      </section><section class="slide" id="slide-11-12">
        <h2 id="todo-app-fetch---fortgeschritten">Todo App: fetch - fortgeschritten</h2>
<pre><code class="language-js">fetch(<span class="hljs-string">'https://jsonplaceholder.typicode.com/todos'</span>)
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (!response.ok) {
      <span class="hljs-keyword">throw</span> response.statusText;
    } <span class="hljs-keyword">else</span> {
      jesponse.json().then(updatePageWithNewTodos);
    }
  })
  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'unable to parse data'</span>))
  .then(updatePageWithNewTodos);</code></pre>

      </section><section class="slide" id="slide-11-13">
        <h2 id="übung">Übung</h2>
<p>Benutzer gibt user-id an, entsprechende todos werden geladen</p>

      </section><section class="slide" id="slide-11-14">
        <h2 id="konfigurieren-des-fetch-requests">Konfigurieren des fetch Requests</h2>
<pre><code class="language-js">fetch(url, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
  <span class="hljs-attr">cache</span>: <span class="hljs-string">'no-cache'</span>,
  <span class="hljs-attr">body</span>: <span class="hljs-string">'{"text": "learn fetch"}'</span>,
  <span class="hljs-attr">headers</span>: { <span class="hljs-string">'content-type'</span>: <span class="hljs-string">'application/json'</span> },
});</code></pre>

      </section><section class="slide" id="slide-11-15">
        <h2 id="eigene-promises">Eigene Promises</h2>
<p>Promise, die nach 1 Sekunde entweder mit hello antwortet oder nicht erfolgreich ist</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> getReply = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>) {
      resolve(<span class="hljs-string">'hello'</span>);
    } <span class="hljs-keyword">else</span> {
      reject(<span class="hljs-string">'no access'</span>);
    }
  }, <span class="hljs-number">1000</span>);
});</code></pre>

      </section><section class="slide" id="slide-11-16">
        <h2 id="promiseall">Promise.all</h2>
<pre><code class="language-js"><span class="hljs-keyword">const</span> promise1 = fetch(<span class="hljs-string">'/users.json'</span>);
<span class="hljs-keyword">const</span> promise2 = fetch(<span class="hljs-string">'/articles.json'</span>);
<span class="hljs-built_in">Promise</span>.all([promise1, promise2])
  .then(<span class="hljs-function"><span class="hljs-params">results</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'all data has loaded'</span>);
  })
  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`one or more requests failed: <span class="hljs-subst">${error}</span>`</span>);
  });</code></pre>
<!--
# (Promise.race)

TODO: google code lab - code-beispiele durchsehen
-->


      </section><section class="slide" id="slide-11-17">
        <h2 id="beispiele">Beispiele</h2>
<ul>
<li>Todo-API (<a href="https://jsonplaceholder.typicode.com">https://jsonplaceholder.typicode.com</a>)</li>
<li>Wetter-API (<a href="https://openweathermap.org">https://openweathermap.org</a>)</li>
</ul>

      </section><section class="slide" id="slide-11-18">
        <h2 id="übungen">Übungen</h2>
<ul>
<li><p><a href="https://developers.google.com/web/ilt/pwa/lab-fetch-api">https://developers.google.com/web/ilt/pwa/lab-fetch-api</a></p>
</li>
<li><p><a href="https://developers.google.com/web/ilt/pwa/lab-promises">https://developers.google.com/web/ilt/pwa/lab-promises</a></p>
</li>
</ul>

      </section></section><section class="section" id="section-12"><section class="slide" id="slide-12-1">
        <h1 id="web-worker">Web worker</h1>

      </section><section class="slide" id="slide-12-2">
        <h2 id="web-worker">Web worker</h2>
<p>Möglichkeit, Scripts im Hintergrund (in einem eigenen Thread) laufen zu lassen</p>
<p>Können genutzt werden, um intensive Berechnungen durchzuführen - blockieren die User-Interaktion mit der Website nicht.</p>

      </section><section class="slide" id="slide-12-3">
        <h2 id="worker-erstellen">Worker erstellen</h2>
<pre><code class="language-js"><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">'worker.js'</span>);</code></pre>

      </section><section class="slide" id="slide-12-4">
        <h2 id="auf-antwort-des-workers-lauschen">Auf Antwort des Workers lauschen</h2>
<pre><code class="language-js">worker.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message</span>) </span>{
  <span class="hljs-built_in">console</span>.log(message.data);
};</code></pre>

      </section><section class="slide" id="slide-12-5">
        <h2 id="dem-worker-zu-arbeiten-geben">Dem Worker zu arbeiten geben</h2>
<pre><code class="language-js">worker.postMessage(<span class="hljs-number">42</span>);</code></pre>

      </section><section class="slide" id="slide-12-6">
        <h2 id="im-worker-selbst">Im Worker selbst</h2>
<pre><code class="language-js">onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message</span>) </span>{
  <span class="hljs-keyword">const</span> result = longComputation();
  postMessage(result);
};</code></pre>

      </section><section class="slide" id="slide-12-7">
        <h2 id="daten-übergeben">Daten übergeben</h2>
<p>Beim hin-und-her-Übergeben von Daten: Daten werden kopiert und als &#39;plain&#39; JS-Objekte verwertet</p>

      </section><section class="slide" id="slide-12-8">
        <h2 id="übung-fibonacci">Übung: Fibonacci</h2>
<p>Im WebWorker laufen lassen:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  }
  <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>);
}</code></pre>

      </section></section><section class="section" id="section-13"><section class="slide" id="slide-13-1">
        <h1 id="service-worker-setup">Service Worker Setup</h1>

      </section><section class="slide" id="slide-13-2">
        <h2 id="service-worker-lebenszyklus">Service Worker Lebenszyklus</h2>
<ul>
<li>register</li>
<li>install</li>
<li>activate</li>
<li>(unregister)</li>
</ul>

      </section><section class="slide" id="slide-13-3">
        <h2 id="einen-service-worker-registrieren">Einen Service Worker registrieren</h2>
<p>Jedes Mal wenn eine Seite geladen wird, rufen wir <code>navigator.serviceWorker.register</code> mit der URL des Service Workers als Parameter auf. Wenn eine neue oder geänderte Service Worker Datei gefunden wird, wird diese <em>installiert</em>.</p>

      </section><section class="slide" id="slide-13-4">
        <h2 id="einen-service-worker-registrieren">Einen Service Worker registrieren</h2>
<pre><code class="language-js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'load'</span>, () =&gt; {
  <span class="hljs-comment">// registration can be defered until</span>
  <span class="hljs-comment">// completion of page load</span>
  <span class="hljs-keyword">if</span> (navigator.serviceWorker) {
    navigator.serviceWorker
      .register(<span class="hljs-string">'/serviceworker.js'</span>)
      .then(<span class="hljs-function"><span class="hljs-params">registration</span> =&gt;</span> {
        <span class="hljs-comment">// is executed if there's a *new* sw file</span>
        <span class="hljs-built_in">console</span>.log(
          <span class="hljs-string">`SW registered for <span class="hljs-subst">${registration.scope}</span>`</span>
        );
      })
      .catch(<span class="hljs-comment">/* reg failed */</span>);
  }
});</code></pre>

      </section><section class="slide" id="slide-13-5">
        <h2 id="service-worker-scope">Service Worker Scope</h2>
<p>Üblicherweise behandelt ein Service Worker alle Anfragen, die auf dem Server in seinem &quot;Ordner&quot; liegen.</p>
<pre><code class="language-js">navigator.serviceWorker.register(<span class="hljs-string">'/css/serviceworker.js'</span>);</code></pre>
<p>Der Service Worker behandelt Anfragen an _ /css/default.css_, aber nicht an <em>/index.html</em>.</p>
<p>Wir können einen Service Worker auch weiter einschränken:</p>
<pre><code class="language-js">navigator.serviceWorker.register(&#39;/css/serviceworker.js&#39;, {
  scope: &#39;/css/xyz/
})</code></pre>

      </section><section class="slide" id="slide-13-6">
        <h2 id="service-worker-installation">Service Worker Installation</h2>
<p>Das <code>install</code> Event wird ausgelöst, wenn es eine neue Service Worker Datei gibt:</p>
<ul>
<li>beim ersten Besuch der Seite</li>
<li>wenn sich die Service Worker Datei geändert hat</li>
</ul>
<p>Guter Zeitpunkt, um Resourcen für die spätere Verwendung herunterzuladen und dem Cache hinzuzufügen</p>

      </section><section class="slide" id="slide-13-7">
        <h2 id="service-worker-installation">Service Worker Installation</h2>
<pre><code class="language-js">self.addEventListener(<span class="hljs-string">'install'</span>, event =&gt; {
  <span class="hljs-built_in">console</span>.log(event);
});</code></pre>

      </section><section class="slide" id="slide-13-8">
        <h2 id="service-worker-aktivierung">Service Worker Aktivierung</h2>
<p>Wenn zuvor kein Service Worker vorhanden war, wird der Service Worker sofort nach der Installation aktiv</p>
<p>Wenn zuvor ein anderer Service Worker vorhanden war, wird dieser nach einem &quot;Neustart&quot; der Anwendung aktiv (wenn alle entsprechenden Tabs geschlossen wurden)</p>
<p>Event <code>activate</code>: gute Gelegenheit, um alte Caches zu bereinigen</p>

      </section><section class="slide" id="slide-13-9">
        <h2 id="service-worker-aktivierung">Service Worker Aktivierung</h2>
<pre><code class="language-js">self.addEventListener(<span class="hljs-string">'activate'</span>, event =&gt; {
  <span class="hljs-built_in">console</span>.log(event);
});</code></pre>

      </section><section class="slide" id="slide-13-10">
        <h2 id="service-worker-aktivierung">Service Worker Aktivierung</h2>
<p>Wir können eine sofortige Aktivierung eines neuen Service Workers aus dem <code>install</code>-Event veranlassen:</p>
<pre><code class="language-js">self.addEventListener(<span class="hljs-string">'install'</span>, event =&gt; {
  self.skipWaiting();
});</code></pre>

      </section><section class="slide" id="slide-13-11">
        <h2 id="service-worker-deinstallieren">Service Worker Deinstallieren</h2>
<p>Deinstallation aller Service Worker für diese Domain:</p>
<pre><code class="language-js">navigator.serviceWorker
  .getRegistrations()
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">registrations</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> registration <span class="hljs-keyword">of</span> registrations) {
      registration.unregister();
    }
  });</code></pre>

      </section></section><section class="section" id="section-14"><section class="slide" id="slide-14-1">
        <h1 id="service-worker-mit-fetch-und-cache">Service Worker mit fetch und cache</h1>

      </section><section class="slide" id="slide-14-2">
        <h2 id="service-worker-mit-fetch-und-cache">Service Worker mit fetch und cache</h2>

      </section><section class="slide" id="slide-14-3">
        <h2 id="fetch---beispiel">fetch - Beispiel</h2>
<pre><code class="language-js"><span class="hljs-comment">// this code can be executed in the</span>
<span class="hljs-comment">// browser console for any website</span>
<span class="hljs-keyword">const</span> url = <span class="hljs-string">'/'</span>;

fetch(url)
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.text())
  .then(<span class="hljs-built_in">console</span>.log);</code></pre>

      </section><section class="slide" id="slide-14-4">
        <h2 id="service-worker-events-fetch">Service Worker Events: Fetch</h2>
<pre><code class="language-js">self.addEventListener(<span class="hljs-string">'fetch'</span>, event =&gt; {
  event.respondWith(
    <span class="hljs-keyword">new</span> Response(<span class="hljs-string">'All pages look like this'</span>)
  );
});</code></pre>

      </section><section class="slide" id="slide-14-5">
        <h2 id="service-worker-events-fetch">Service Worker Events: Fetch</h2>
<p>Übung: wir erstellen eine kleine lokale Website mit Seiten wie <em>/home</em>, <em>/about</em>, ...</p>

      </section><section class="slide" id="slide-14-6">
        <h2 id="service-worker-events-fetch">Service Worker Events: fetch</h2>
<!--
there are two $ signs in regexes in this code
if they are at the very end of the string
they will mess up the result
-->

<pre><code class="language-js">self.addEventListener(<span class="hljs-string">'fetch'</span>, event =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'/about/$ '</span>).test(event.request.url)) {
    event.respondWith(<span class="hljs-keyword">new</span> Response(<span class="hljs-string">'About'</span>));
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'/a$ '</span>).test(event.request.url)) {
    event.respondWith(<span class="hljs-keyword">new</span> Response(<span class="hljs-string">'Home'</span>));
  } <span class="hljs-keyword">else</span> {
    event.respondWith(<span class="hljs-keyword">new</span> Response(<span class="hljs-string">'404'</span>));
  }
});</code></pre>

      </section><section class="slide" id="slide-14-7">
        <h2 id="service-worker-events-fetch">Service Worker Events: fetch</h2>
<p>Übung: Loggen aller Netzwerkanfragen, die Netzwerkanfragen dann mittels <code>fetch</code> beantworkten lassen</p>

      </section><section class="slide" id="slide-14-8">
        <h2 id="service-worker-events-fetch">Service Worker Events: fetch</h2>
<pre><code class="language-js">self.addEventListener(<span class="hljs-string">'fetch'</span>, event =&gt; {
  <span class="hljs-built_in">console</span>.log(event);
  <span class="hljs-keyword">return</span> fetch(event.request);
});</code></pre>

      </section></section><section class="section" id="section-15"><section class="slide" id="slide-15-1">
        <h1 id="service-worker-mit-fetch-und-cache">Service Worker mit fetch und cache</h1>

      </section><section class="slide" id="slide-15-2">
        <h2 id="service-worker-mit-fetch-und-cache">Service Worker mit fetch und cache</h2>
<p>Wichtige verwandte Technologien:</p>
<ul>
<li>fetch (Netzwerkanfragen senden)</li>
<li>cache (Resultate cachen)</li>
</ul>

      </section><section class="slide" id="slide-15-3">
        <h2 id="cache">Cache</h2>
<p>= &quot;a request to response map&quot;</p>

      </section><section class="slide" id="slide-15-4">
        <h2 id="auf-caches-zugreifen">Auf Caches zugreifen</h2>
<p>Durch die globale Variable <code>caches.open</code> oder <code>self.caches.open</code> im Service Worker</p>
<p>Promise:</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> myCache;
caches.open(<span class="hljs-string">'test'</span>, mc =&gt; {
  myCache = mc;
});</code></pre>

      </section><section class="slide" id="slide-15-5">
        <h2 id="methoden">Methoden</h2>
<p>Cache-Methoden:</p>
<ul>
<li><code>myCache.add(request)</code></li>
<li><code>myCache.addAll(requests)</code></li>
<li><code>myCache.put(request, response)</code></li>
<li><code>myCache.delete(request)</code></li>
<li><code>myCache.match(request)</code></li>
<li><code>myCache.matchAll(requests)</code></li>
</ul>
<p>Die Variable <code>request</code> kann entweder ein String sein, oder ein <code>Request</code> objekt.</p>

      </section><section class="slide" id="slide-15-6">
        <h2 id="cache---addall">Cache - add(All)</h2>
<p>Wir übergeben eine URL; die Resource wird automatisch angefragt und gespeichert</p>
<pre><code class="language-js">cache.add(<span class="hljs-string">'/main.js'</span>);

cache.addAll([<span class="hljs-string">'/'</span>, <span class="hljs-string">'/index.html'</span>, <span class="hljs-string">'/main.js'</span>]);</code></pre>

      </section><section class="slide" id="slide-15-7">
        <h2 id="cache---put">Cache - put</h2>
<p>Kann verwendet werden, wenn wir schon über die Antwort verfügen</p>
<pre><code class="language-js">fetch(<span class="hljs-string">'myurl'</span>).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(response.clone());
  cache.put(<span class="hljs-string">'myurl'</span>, response.clone());
  cache.put(<span class="hljs-string">'otherurl'</span>, response);
});</code></pre>

      </section><section class="slide" id="slide-15-8">
        <h2 id="cache---delete">Cache - delete</h2>
<pre><code class="language-js">cache.delete(<span class="hljs-string">'myurl'</span>);</code></pre>

      </section><section class="slide" id="slide-15-9">
        <h2 id="cache---match">Cache - match</h2>
<p>Einen Eintrag aus dem Cache holen, der auf einen bestimmten Request passt</p>
<pre><code class="language-js"><span class="hljs-comment">// returns a response or undefined</span>
<span class="hljs-keyword">const</span> content = cache.match(<span class="hljs-string">'myurl'</span>);</code></pre>

      </section><section class="slide" id="slide-15-10">
        <h2 id="beispiel-cache-only-kurz">Beispiel: cache only (kurz)</h2>
<p>Eine Anwendung, die Resourcen bei der Installation cacht und sie dauerhaft aus dem Cache zur Verfügung stellt</p>
<pre><code class="language-js">self.addEventListener(<span class="hljs-string">'install'</span>, () =&gt; {
  cache.addAll([<span class="hljs-string">'/'</span>, <span class="hljs-string">'/index.html'</span>, <span class="hljs-string">'/about'</span>])
})

self.addEventListener(<span class="hljs-string">'fetch'</span>, event =&gt; {
  event.respondWith(
    caches.match(event.request);
  )
})</code></pre>

      </section><section class="slide" id="slide-15-11">
        <h2 id="beispiel-cache-only-ganzer-code">Beispiel: cache only (ganzer Code)</h2>
<pre><code class="language-js">self.addEventListener(<span class="hljs-string">'install'</span>, installEvent =&gt; {
  <span class="hljs-comment">// wait for the cache to be populated;</span>
  <span class="hljs-comment">// abort install on error</span>
  installEvent.waitUntil(
    caches.open(<span class="hljs-string">'app-shell-cache-v3'</span>).then(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {
      <span class="hljs-keyword">return</span> cache.addAll([<span class="hljs-string">'/'</span>, <span class="hljs-string">'/index.html'</span>, <span class="hljs-string">'/about'</span>]);
    })
  );
  <span class="hljs-comment">// optional - don't abort install on error</span>
  caches.open(<span class="hljs-string">'app-shell-cache-v3'</span>).then(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {
    cache.addAll[<span class="hljs-string">'/icon1.png'</span>];
  });
});</code></pre>

      </section><section class="slide" id="slide-15-12">
        <h2 id="beispiel-cache-only---waituntil">Beispiel: cache only - waitUntil</h2>
<p>Ein Aufruf von <code>waitUntil</code> kann verwendet werden, um anzuzeigen, ob die Installation erfolgreich war - dier Service Worker wird nur bei Erfolg aktiviert</p>

      </section><section class="slide" id="slide-15-13">
        <h2 id="beispiel-den-cache-aktualisieren">Beispiel: den Cache aktualisieren</h2>
<p>alte Einträge löschen:</p>
<pre><code class="language-js">self.addEventListener(<span class="hljs-string">'activate'</span>, activateEvent =&gt; {
  activateEvent.waitUntil(
    <span class="hljs-built_in">Promise</span>.all([
      caches.delete(<span class="hljs-string">'app-shell-cache-v2'</span>),
      caches.delete(<span class="hljs-string">'app-shell-cache-v1'</span>),
    ])
  );
});</code></pre>

      </section><section class="slide" id="slide-15-14">
        <h2 id="beispiel-aus-dem-cache-laden---mit-netzwerk-fallback">Beispiel: Aus dem Cache laden - mit Netzwerk-Fallback</h2>
<pre><code class="language-js">self.addEventListener(<span class="hljs-string">'fetch'</span>, event =&gt; {
  event.respondWith(
    caches
      .match(event.request)
      .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response || fetch(event.request))
  );
});</code></pre>

      </section><section class="slide" id="slide-15-15">
        <h2 id="beispiel-den-cache-bei-jedem-request-aktualisieren">Beispiel: Den Cache bei jedem Request aktualisieren</h2>
<pre><code class="language-js">self.addEventListener(<span class="hljs-string">'fetch'</span>, event =&gt; {
  event.respondWith(
    fetch(event.request).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
      cache.put(event.request, response.clone());
      <span class="hljs-keyword">return</span> response;
    })
  );
});</code></pre>

      </section><section class="slide" id="slide-15-16">
        <h2 id="beispiel-network---falling-back-to-cache---falling-back-to-default-asset-eg-user-avatar">Beispiel: Network - Falling back to Cache - Falling back to default asset (e.g. user avatar)</h2>

      </section><section class="slide" id="slide-15-17">
        <h2 id="übung-scripting-the-service-worker">Übung: scripting the service worker</h2>
<p><a href="https://developers.google.com/web/ilt/pwa/lab-scripting-the-service-worker">https://developers.google.com/web/ilt/pwa/lab-scripting-the-service-worker</a></p>

      </section></section><section class="section" id="section-16"><section class="slide" id="slide-16-1">
        <h1 id="service-worker-beispiele">Service Worker Beispiele</h1>

      </section><section class="slide" id="slide-16-2">
        <h2 id="offline-app-installation">Offline App Installation</h2>
<pre><code class="language-js">self.addEventListener(<span class="hljs-string">'install'</span>, event =&gt; {
  event.waitUntil(
    caches.open(cacheName).then(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'opened cache'</span>);
      <span class="hljs-comment">// Resultat von addAll ist ein Promise</span>
      <span class="hljs-keyword">return</span> cache.addAll(urlsToCache);
    })
  );
});</code></pre>

      </section><section class="slide" id="slide-16-3">
        <h2 id="offline-app-installation---workbox">Offline App Installation - workbox</h2>
<pre><code class="language-js">workbox.precaching.precache(urlsToCache);</code></pre>

      </section><section class="slide" id="slide-16-4">
        <h2 id="offline-app-fetch">Offline App fetch</h2>
<pre><code class="language-js">self.addEventListener(<span class="hljs-string">'fetch'</span>, event =&gt; {
  event.respondWith(caches.match(event.request));
});</code></pre>

      </section><section class="slide" id="slide-16-5">
        <h2 id="offline-app-fetch---workbox">Offline App fetch - workbox</h2>
<pre><code class="language-js">workbox.routing.registerRoute(
  <span class="hljs-string">'.*'</span>,
  workbox.strategies.cacheOnly
);</code></pre>

      </section></section><section class="section" id="section-17"><section class="slide" id="slide-17-1">
        <h1 id="datenspeicherung">Datenspeicherung</h1>
<h3 id="localstorage-und-indexeddb">localStorage und indexedDB</h3>

      </section><section class="slide" id="slide-17-2">
        <h2 id="überblick">Überblick</h2>
<ul>
<li>localStorage: einfacher key-value-Store mit Textwerten)</li>
<li>indexedDB: &quot;echte Datenbank&quot;</li>
</ul>

      </section></section><section class="section" id="section-18"><section class="slide" id="slide-18-1">
        <h1 id="localstorage">localStorage</h1>

      </section><section class="slide" id="slide-18-2">
        <h2 id="localstorage">localStorage</h2>
<p><em>localStorage</em> ist ein einfacher key-value-Store im Browser; Sowohl <em>keys</em> als auch <em>values</em> sind strings</p>
<p>Der Browser speichert Daten seperat für jede Domain</p>

      </section><section class="slide" id="slide-18-3">
        <h2 id="localstorage">localStorage</h2>
<p>wichtige Methoden:</p>
<ul>
<li><code>localStorage.setItem(&#39;name&#39;, &#39;John&#39;)</code></li>
<li><code>localStorage.getItem(&#39;name&#39;)</code></li>
<li><code>localStorage.removeItem(&#39;name&#39;)</code></li>
</ul>

      </section><section class="slide" id="slide-18-4">
        <h2 id="localstorage">localStorage</h2>
<p>Speichern und Laden von Daten:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> todoString = <span class="hljs-built_in">JSON</span>.stringify(todos);
localStorage.setItem(<span class="hljs-string">'todos'</span>, todoString);</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">const</span> todoString = localStorage.getItem(<span class="hljs-string">'todos'</span>);
todos = <span class="hljs-built_in">JSON</span>.parse(todoString);</code></pre>

      </section></section><section class="section" id="section-19"><section class="slide" id="slide-19-1">
        <h1 id="indexeddb">indexedDB</h1>

      </section><section class="slide" id="slide-19-2">
        <h2 id="indexeddb">indexedDB</h2>
<p>Vollwertige Datenbank</p>
<p>Vorteile gegenüber localStorage:</p>
<ul>
<li>non-blocking</li>
<li>schneller (Abfrage mit Indizes)</li>
<li>Aufteilung in &quot;Tabellen&quot; (stores)</li>
<li>verschiedene Datentypen</li>
</ul>
<p>Nachteil: Komplexeres Interface</p>

      </section><section class="slide" id="slide-19-3">
        <h2 id="indexeddb-interfaces">indexedDB Interfaces</h2>
<ul>
<li>idb</li>
<li>dexie</li>
<li>localForage</li>
</ul>

      </section><section class="slide" id="slide-19-4">
        <h2 id="indexeddb-promised-idb">indexedDB promised (idb)</h2>
<p>library, die es erlaubt, bei indexedDB mit Promises zu arbeiten</p>
<p><a href="https://github.com/jakearchibald/idb">https://github.com/jakearchibald/idb</a></p>
<p>Einbinden über CDN: <a href="https://cdn.jsdelivr.net/npm/idb@2.1.2/lib/idb.min.js">https://cdn.jsdelivr.net/npm/idb@2.1.2/lib/idb.min.js</a></p>

      </section><section class="slide" id="slide-19-5">
        <h2 id="idb-grundlagen">idb Grundlagen</h2>

      </section><section class="slide" id="slide-19-6">
        <h2 id="idb-grundlagen-open--upgrade">idb Grundlagen: open &amp; upgrade</h2>
<p>Erstellen / Öffnen einer DB; gibt ein Promise zurück</p>
<pre><code class="language-js">idb.open(name, version, upgradeCallback);</code></pre>

      </section><section class="slide" id="slide-19-7">
        <h2 id="idb-grundlagen-open--upgrade">idb Grundlagen: open &amp; upgrade</h2>
<p>Beispiel</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> upgradeCallback = <span class="hljs-function"><span class="hljs-params">upgradeDb</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (!upgradeDb.objectStoreNames.contains(<span class="hljs-string">'todos'</span>)) {
    upgradeDb.createObjectStore(<span class="hljs-string">'todos'</span>, {
      <span class="hljs-attr">autoIncrement</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">keyPath</span>: <span class="hljs-string">'key'</span>,
    });
  }
};

<span class="hljs-keyword">const</span> dbPromise = idb.open(<span class="hljs-string">'todo-db'</span>, <span class="hljs-number">1</span>, upgradeCallback);</code></pre>

      </section><section class="slide" id="slide-19-8">
        <h2 id="upgrade">Upgrade</h2>
<p>upgrade = callback, das insbesondere genutzt werden kann, um auf ein neues Datenschema zu wechseln</p>
<p>zb können darin Stores erstellt, gelöscht oder abgeändert werden</p>
<p>Callbackfunktion wird immer aufgerufen, wenn sich die Versionsnummer der Datenbank erhöht</p>

      </section><section class="slide" id="slide-19-9">
        <h2 id="keys">Keys</h2>
<p>Jedes Element im object store hat einen einzigartigen key (~id);</p>
<p>Der key kann ein Eintrag im Objekt sein oder ein unabhängiger Wert</p>

      </section><section class="slide" id="slide-19-10">
        <h2 id="keys-numerische-id">Keys: numerische id</h2>
<pre><code class="language-js">upgradeDb.createObjectStore(<span class="hljs-string">'todos'</span>, {
  <span class="hljs-attr">autoIncrement</span>: <span class="hljs-literal">true</span>,
});</code></pre>

      </section><section class="slide" id="slide-19-11">
        <h2 id="keys-numerische-id-die-im-objekt-abgespeichert-wird">Keys: numerische id, die im Objekt abgespeichert wird</h2>
<pre><code class="language-js">upgradeDb.createObjectStore(<span class="hljs-string">'todos'</span>, {
  <span class="hljs-attr">autoIncrement</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">keyPath</span>: <span class="hljs-string">'key'</span>,
});</code></pre>

      </section><section class="slide" id="slide-19-12">
        <h2 id="keys-eintrag-im-objekt">Keys: Eintrag im Objekt</h2>
<pre><code class="language-js"><span class="hljs-comment">// email als id</span>
upgradeDb.createObjectStore(<span class="hljs-string">'users'</span>, {
  <span class="hljs-attr">keyPath</span>: <span class="hljs-string">'email'</span>,
});</code></pre>

      </section><section class="slide" id="slide-19-13">
        <h2 id="transaktionen">Transaktionen</h2>
<p>Transaktion = Gruppe von Operationen auf der Datenbank (auslesen / hinzufügen / überschreiben ...)</p>

      </section><section class="slide" id="slide-19-14">
        <h2 id="transaktionen---schritte">Transaktionen - Schritte</h2>
<ol>
<li>Datenbankobjekt holen (idb.open)</li>
<li>Eine Transaktion auf einem oder mehreren Stores beginnen (zwei Modi: &#39;readonly&#39; (Standard) oder &#39;readwrite&#39;)</li>
<li>Object Store öffnen</li>
<li>Operation auf Object Store ausführen</li>
</ol>

      </section><section class="slide" id="slide-19-15">
        <h2 id="datenbankobjekt-holen">Datenbankobjekt holen</h2>
<pre><code class="language-js"><span class="hljs-keyword">let</span> db;

idb.open(<span class="hljs-string">'todo-db'</span>, <span class="hljs-number">1</span>).then(<span class="hljs-function"><span class="hljs-params">openedDb</span> =&gt;</span> {
  db = openedDb;
});</code></pre>

      </section><section class="slide" id="slide-19-16">
        <h2 id="daten-hinzufügen-add">Daten hinzufügen (add)</h2>
<pre><code class="language-js"><span class="hljs-keyword">const</span> transaction = db.transaction([<span class="hljs-string">'todos'</span>], <span class="hljs-string">'readwrite'</span>);
<span class="hljs-keyword">const</span> todoStore = transaction.objectStore(<span class="hljs-string">'todos'</span>);
todoStore.add({ <span class="hljs-attr">text</span>: <span class="hljs-string">'groceries'</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> });</code></pre>

      </section><section class="slide" id="slide-19-17">
        <h2 id="daten-überschreiben-put">Daten überschreiben (put)</h2>
<pre><code class="language-js"><span class="hljs-keyword">const</span> transaction = db.transaction([<span class="hljs-string">'todos'</span>], <span class="hljs-string">'readwrite'</span>);
<span class="hljs-keyword">const</span> todoStore = transaction.objectStore(<span class="hljs-string">'todos'</span>);
<span class="hljs-comment">// ersetze den Eintrag mit index 1</span>
todoStore.put({ <span class="hljs-attr">text</span>: <span class="hljs-string">'groceris'</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">1</span> });</code></pre>

      </section><section class="slide" id="slide-19-18">
        <h2 id="daten-löschen">Daten löschen</h2>
<pre><code class="language-js"><span class="hljs-keyword">const</span> transaction = db.transaction([<span class="hljs-string">'todos'</span>], <span class="hljs-string">'readwrite'</span>);
<span class="hljs-keyword">const</span> todoStore = transaction.objectStore(<span class="hljs-string">'todos'</span>);
todoStore.delete(<span class="hljs-number">1</span>);</code></pre>

      </section><section class="slide" id="slide-19-19">
        <h2 id="daten-auslesen-getall">Daten auslesen (getAll)</h2>
<pre><code class="language-js"><span class="hljs-keyword">const</span> transaction = db.transaction([<span class="hljs-string">'artists'</span>], <span class="hljs-string">'readonly'</span>);
<span class="hljs-keyword">const</span> artistsStore = transaction.objectStore(<span class="hljs-string">'artists'</span>);
artistsStore.getAll().then(<span class="hljs-built_in">console</span>.log);</code></pre>

      </section><section class="slide" id="slide-19-20">
        <h2 id="daten-auslesen-get">Daten auslesen (get)</h2>
<p>Auslesen anhand des keys:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> transaction = db.transaction([<span class="hljs-string">'artists'</span>], <span class="hljs-string">'readonly'</span>);
<span class="hljs-keyword">const</span> artistsStore = transaction.objectStore(<span class="hljs-string">'artists'</span>);
artistsStore.get(<span class="hljs-number">1</span>).then(<span class="hljs-built_in">console</span>.log);</code></pre>

      </section><section class="slide" id="slide-19-21">
        <h2 id="daten-auslesen---via-indizes">Daten auslesen - via indizes</h2>
<p>Die Einträge werden in der Datenbank im wesentlichen nach dem key sortiert abgelegt.</p>
<p>Dadurch kann von der Datenbank schnell nach dem key gesucht werden.</p>
<p>Beispiel: In einem Telefonbuch kann man schnell nach einem Nachnamen suchen, jedoch nicht nach einem Vornamen oder einer Telefonnummer</p>

      </section><section class="slide" id="slide-19-22">
        <h2 id="indizes">Indizes</h2>
<p>Um schnell nach etwas anderem als dem primary key zu suchen: zusätzlicher Index (aber: größerer Datenverbrauch)</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> store = upgradeDb.createObjectStore(<span class="hljs-string">'contacts'</span>);
store.createIndex(<span class="hljs-string">'email'</span>, <span class="hljs-string">'email'</span>, { <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span> });
store.createIndex(<span class="hljs-string">'firstName'</span>, <span class="hljs-string">'firstName'</span>);
store.createIndex(<span class="hljs-string">'name'</span>, [<span class="hljs-string">'lastName'</span>, <span class="hljs-string">'firstName'</span>]);</code></pre>

      </section><section class="slide" id="slide-19-23">
        <h2 id="indizes">Indizes</h2>
<pre><code class="language-js"><span class="hljs-keyword">const</span> nameIndex = objectStore.index(<span class="hljs-string">'name'</span>);
nameIndex.get([<span class="hljs-string">'Andy'</span>, <span class="hljs-string">'Jones'</span>]).then(...)</code></pre>

      </section><section class="slide" id="slide-19-24">
        <h2 id="übungen">Übungen</h2>
<ul>
<li>Slides: <a href="https://developers.google.com/web/ilt/pwa/working-with-indexeddb-slides">https://developers.google.com/web/ilt/pwa/working-with-indexeddb-slides</a></li>
<li>Lab: <a href="https://developers.google.com/web/ilt/pwa/lab-indexeddb">https://developers.google.com/web/ilt/pwa/lab-indexeddb</a></li>
</ul>

      </section></section><section class="section" id="section-20"><section class="slide" id="slide-20-1">
        <h1 id="notifications">Notifications</h1>
<!-- siehe auch: https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API/Using_the_Notifications_API -->


      </section><section class="slide" id="slide-20-2">
        <h2 id="notifications">Notifications</h2>
<p>Möglichkeit, für den Benutzer Benachrichtigungen außerhalb der Anwendung darzustellen (Betriebssystems-Benachrichtigungen)</p>

      </section><section class="slide" id="slide-20-3">
        <h2 id="erlaubnis-einholen">Erlaubnis einholen</h2>
<pre><code class="language-js"><span class="hljs-keyword">let</span> notificationsAllowed;

Notification.requestPermission().then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (result === <span class="hljs-string">'granted'</span>) {
    notificationsAllowed = <span class="hljs-literal">true</span>;
  }
});</code></pre>
<p>Kann zu jeder Seite in der Browser-Konsole ausprobiert werden</p>

      </section><section class="slide" id="slide-20-4">
        <h2 id="nachricht-darstellen">Nachricht darstellen</h2>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (Notification.permission === <span class="hljs-string">'granted'</span>) {
  <span class="hljs-keyword">new</span> Notification(<span class="hljs-string">'Hello world'</span>);
}</code></pre>

      </section><section class="slide" id="slide-20-5">
        <h2 id="nachricht-optionen">Nachricht-Optionen</h2>
<pre><code class="language-js"><span class="hljs-keyword">new</span> Notification(<span class="hljs-string">'cloudy'</span>, {
  <span class="hljs-attr">body</span>: <span class="hljs-string">'The weather in Vienna is cloudy'</span>,
  <span class="hljs-attr">icon</span>: <span class="hljs-string">'static/images/cloudy.png'</span>,
  <span class="hljs-attr">vibrate</span>: [<span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>],
});</code></pre>

      </section></section><section class="section" id="section-21"><section class="slide" id="slide-21-1">
        <h1 id="benachrichtigungen-aus-dem-service-worker">Benachrichtigungen aus dem Service Worker</h1>

      </section><section class="slide" id="slide-21-2">
        <h2 id="benachrichtigungen-aus-dem-service-worker">Benachrichtigungen aus dem Service Worker</h2>
<p>Die bisherigen Benachrichtigungen stammten aus einem bestimmten Browser-Fenster. Benachrichtigungen können auch aus dem Service Worker dargestellt werden. Diese Benachrichtigungen bieten mehr Möglichkeiten, insbesondere:</p>
<ul>
<li>Mit den Benachrichtigungen kann über Buttons interagiert werden</li>
<li>Benachrichtigungen können angezeigt werden, wenn die Website nicht geöffnet ist</li>
</ul>

      </section><section class="slide" id="slide-21-3">
        <h2 id="zugriff-auf-die-service-worker-registrierung">Zugriff auf die Service Worker Registrierung:</h2>
<pre><code class="language-js"><span class="hljs-keyword">let</span> serviceWorkerRegistration;

navigator.serviceWorker
  .getRegistration()
  .then(<span class="hljs-function"><span class="hljs-params">registration</span> =&gt;</span> {
    serviceWorkerRegistration = registration;
  });</code></pre>

      </section><section class="slide" id="slide-21-4">
        <h2 id="benachrichtigungen-aus-dem-service-worker">Benachrichtigungen aus dem Service Worker</h2>
<pre><code class="language-js">serviceWorkerRegistration.showNotification(<span class="hljs-string">'cloudy'</span>, {
  <span class="hljs-attr">body</span>: <span class="hljs-string">'The weather in Vienna is cloudy'</span>,
  <span class="hljs-attr">icon</span>: <span class="hljs-string">'static/images/cloudy.png'</span>,
  <span class="hljs-attr">vibrate</span>: [<span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>],
  <span class="hljs-comment">// new option available:</span>
  actions: [
    { <span class="hljs-attr">action</span>: <span class="hljs-string">'close'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'Close'</span> },
    { <span class="hljs-attr">action</span>: <span class="hljs-string">'details'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'Details'</span> },
  ],
});</code></pre>

      </section><section class="slide" id="slide-21-5">
        <h2 id="auf-benachrichtigungsaktionen-reagieren">Auf Benachrichtigungsaktionen reagieren</h2>
<p>Zwei Events im ServiceWorker:</p>
<ul>
<li><code>notificationclick</code></li>
<li><code>notificationclose</code></li>
</ul>
<!--
evtl in Firefox testen, da Probleme mit Chrome
-->

<!--
# Kommunikation zurück zum Browser-Fenster

eher komplex, da es verschiedene Fenster zu einem Service-Worker geben kann
-->


      </section><section class="slide" id="slide-21-6">
        <h2 id="übungen-labs">Übungen (Labs)</h2>
<p><a href="https://developers.google.com/web/ilt/pwa/lab-integrating-web-push">https://developers.google.com/web/ilt/pwa/lab-integrating-web-push</a></p>
<p>1-3</p>
<p>Entfernen der service-worker in FF: about:debugging -&gt; worker</p>
<!--
Dauer: ca 50 min
-->


      </section></section><section class="section" id="section-22"><section class="slide" id="slide-22-1">
        <h1 id="push-benachrichtigungen">Push-Benachrichtigungen</h1>

      </section><section class="slide" id="slide-22-2">
        <h2 id="push-benachrichtigungen">Push-Benachrichtigungen</h2>
<ul>
<li>Möglichkeit, Benachrichtigungen von einem Server zu unserer PWA senden</li>
<li>funktioniert auch, wenn die Anwendung nicht läuft (Am Desktop muss allerdings zumindest eine Instanz des Browsers geöffnet sein)</li>
</ul>

      </section><section class="slide" id="slide-22-3">
        <h2 id="push-benachrichtigungen---grundlagen">Push-Benachrichtigungen - Grundlagen</h2>
undefined


      </section><section class="slide" id="slide-22-4">
        <h2 id="push-benachrichtigungen---grundlagen">Push-Benachrichtigungen - Grundlagen</h2>
<p>Push-Benachrichtigungen werden über den Browserhersteller (Google, Mozilla, ...) gesendet. Dies geschieht über URLs wie diese:</p>
<ul>
<li><code>https://android.googleapis.com/gcm/send/IDENTIFIER</code></li>
<li><code>https://updates.push.services.mozilla.com/wpush/v1/IDENTIFIER</code></li>
</ul>

      </section><section class="slide" id="slide-22-5">
        <h2 id="push-benachrichtigungen---ablauf">Push-Benachrichtigungen - Ablauf</h2>
undefined


      </section><section class="slide" id="slide-22-6">
        <h2 id="push-benachrichtigungen---ablauf">Push-Benachrichtigungen - Ablauf</h2>
<ul>
<li>Benutzer besucht eine Web App, aktiviert Benachrichtigungen</li>
<li>Web App kommuniziert mit dem Browserhersteller; der Browserhersteller generiert eine eindeutige URL und einen kryptographischen Schlüssel und übergibt diese an den Browser</li>
<li>Web App teilt diese URL mit dem Backend</li>
<li>Aus dem Backend können wir mit Hilfe dieser Daten Nachrichten an den Service Worker schicken</li>
</ul>

      </section><section class="slide" id="slide-22-7">
        <h2 id="push-benachrichtigungen">Push-Benachrichtigungen</h2>
<p>Aktivierung im Browser:</p>
<pre><code class="language-js">serviceWorkerRegistration.pushManager
  .subscribe({
    <span class="hljs-attr">userVisibleOnly</span>: <span class="hljs-literal">true</span>,
  })
  .then(<span class="hljs-function"><span class="hljs-params">subscription</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(subscription.endpoint);
    <span class="hljs-comment">// could be: https://android.googleapis.com/gcm/send/..</span>
  });</code></pre>

      </section><section class="slide" id="slide-22-8">
        <h2 id="push-benachrichtigunen">Push-Benachrichtigunen</h2>
<p>Aktuelle Subscription auslesen:</p>
<pre><code class="language-js">serviceWorkerRegistration.pushManager
  .getSubscription()
  .then(<span class="hljs-function"><span class="hljs-params">subsription</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (subscription === <span class="hljs-literal">undefined</span>) {
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(subscription.toJSON()));
      <span class="hljs-comment">// send the subscription object to our server</span>
    }
  });</code></pre>

      </section><section class="slide" id="slide-22-9">
        <h2 id="push-benachrichtigungen---das-subscription-objekt">Push-Benachrichtigungen - Das Subscription-Objekt</h2>
<p>Sobald wir diese Daten am Server haben, können wir Benachrichtigungen an den Client senden</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"endpoint"</span>: <span class="hljs-string">"https://android.googleapis.com/gcm/send/f2L..."</span>,
  <span class="hljs-attr">"keys"</span>: {
    <span class="hljs-attr">"auth"</span>: <span class="hljs-string">"5I2BuN..."</span>,
    <span class="hljs-attr">"p256dh"</span>: <span class="hljs-string">"BLc45n..."</span>
  }
}</code></pre>

      </section><section class="slide" id="slide-22-10">
        <h2 id="push-benachrichtigungen---serverseitig">Push-Benachrichtigungen - serverseitig</h2>
<p>in node.js:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> webPush = <span class="hljs-built_in">require</span>(<span class="hljs-string">'web-push'</span>);

<span class="hljs-keyword">const</span> subscripton = {
  <span class="hljs-attr">endpoint</span>: <span class="hljs-string">'...'</span>,
  <span class="hljs-attr">keys</span>: { <span class="hljs-attr">auth</span>: <span class="hljs-string">'...'</span>, <span class="hljs-attr">p256dh</span>: <span class="hljs-string">'...'</span> },
};

webPush.sendNotification(subscription, <span class="hljs-string">'Hello world!'</span>);</code></pre>

      </section><section class="slide" id="slide-22-11">
        <h2 id="push-benachrichtigungen-in-chrome">Push-Benachrichtigungen in Chrome</h2>
<p>In Chrome werden Push-Benachrichtigungen via <em>Firebase Cloud Messaging</em> (früher: <em>Google Cloud Messaging</em>) gesendet</p>
<p>Für die Entwicklung benötigen wir einen Firebase Account und API key</p>
<pre><code class="language-js">webPush.sendNotification(subscription, <span class="hljs-string">'Hello world!'</span>, {
  <span class="hljs-attr">gcmAPIKey</span>: <span class="hljs-string">'....'</span>,
});</code></pre>

      </section><section class="slide" id="slide-22-12">
        <h2 id="push-benachrichtigungen-lab">Push-Benachrichtigungen: Lab</h2>
<p><a href="https://developers.google.com/web/ilt/pwa/lab-integrating-web-push">https://developers.google.com/web/ilt/pwa/lab-integrating-web-push</a></p>

      </section></section><section class="section" id="section-23"><section class="slide" id="slide-23-1">
        <h1 id="resourcen">Resourcen</h1>
<p><a href="https://developers.google.com/web/ilt/pwa/">https://developers.google.com/web/ilt/pwa/</a></p>

      </section></section>

    </div>
    <div id="navigation-arrows">
      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="navigation-arrows-svg"
        xml:space="preserve" width="100%" height="100%" viewBox="-110 -110 220 220">
        <path class="arrow right" d="M70,-30L100,0L70,30" />
        <path class="arrow down" d="M-30,70L0,100L30,70" />
        <path class="arrow left" d="M-70,-30L-100,0L-70,30" />
        <path class="arrow up" d="M-30,-70L0,-100L30,-70" />
      </svg>
    </div>
  </div>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      width: 100vw;
      height: 100vh;
      margin: 0px;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: rgb(150, 150, 150);
      font-family: -apple-system, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
      line-height: 1.5rem;
    }

    p, ul, pre {
      margin-top: 0;
    }

    ul {
      padding-left: 1.5rem;
    }

    h1, h2, h3 {
      margin-top: 0px;
      font-weight: 600;
    }

    h1 {
      margin-top: 5vh;
      text-align: center;
      font-size: 2rem;
    }

    h2 {
      margin-bottom: 1.5em;
    }

    svg {
      width: 100%;
      height: auto;
    }

    .section {
      height: 100%;
      display: none;
    }

    .section.active {
      display: block;
    }

    .slide {
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    .slide.inactive {
      display: none;
    }

    #canvas {
      box-shadow: 0 0.5vh 1vh rgba(0, 0, 0, 0.3);
      background-color: #f8f8f8;
      position: relative;
      display: flex;
    }

    #canvas-content {
      width: 100%;
      height: 100%;
    }

    #canvas-content .note {
      display: none;
    }

    #canvas-content img {
      margin: 0px auto;
      display: block;
    }

    @media (min-aspect-ratio: 8/5) {

      html {
        font-size: 3.5vh;
      }

      /* wide screen */
      #canvas {
        width: calc(100vh / 5 * 8);
        height: 100vh;
        padding: 10vh;
        padding-top: 5vh;
      }
    }

    @media (max-aspect-ratio: 8/5) {

      html {
        font-size: calc(3.5vw * 5 / 8);
      }

      /* narrow screen */
      #canvas {
        width: 100vw;
        height: calc(100vw * 5 / 8);
        padding: calc(10vh * 5 / 8);
        padding-top: calc(5vh * 5 / 8);
      }
    }

    pre {
      background-color: rgb(224, 233, 240);
      box-shadow: 0 0.5vh 1vh rgba(0, 0, 0, 0.2);
      padding: 0.5em 1em;
      line-height: 1.2em;
      overflow: auto;
    }

    #navigation-arrows {
      position: absolute;
      right: 2rem;
      top: 2rem;
      height: 3rem;
      width: 3rem;
    }

    #navigation-arrows .arrow {
      stroke: lightblue;
      /*stroke-width: 0.8em; Chrome behaves differently with ems here */
      stroke-width: 16px;
      stroke-linecap: round;
      fill: none;
      cursor: pointer;
    }

    td,
    th {
      padding: 0.2em 0.8em;
    }

    th {
      text-align: start;
    }
  </style>
  <script>
    let presenterWindow;
    let activeSlide;
    let slideCount;

    const arrowUp = document.querySelector('.arrow.up');
    const arrowDown = document.querySelector('.arrow.down');
    const arrowRight = document.querySelector('.arrow.right');
    const arrowLeft = document.querySelector('.arrow.left');
    arrowUp.addEventListener('click',
      () => {activateSlideSafe(activeSlide[0], activeSlide[1] - 1);}
    );
    arrowDown.addEventListener('click',
      () => {activateSlideSafe(activeSlide[0], activeSlide[1] + 1);}
    );
    arrowLeft.addEventListener('click',
      () => {activateSlideSafe(activeSlide[0] - 1, 1);}
    );
    arrowRight.addEventListener('click',
      () => {activateSlideSafe(activeSlide[0] + 1, 1);}
    )
    const init = () => {
      slideCount = countSlides();
      activateSlideSafe(1, 1);
      addKeyControls();
      addSwipeControls();
    }

    // count slides
    const countSlides = () => {
      const counts = [];
      return [...document.querySelectorAll('.section')].map(section => section.childNodes.length);
    }

    const updateVisible = () => {
      for (let section of document.querySelectorAll('.section')) {
        if (section.id === `section-${activeSlide[0]}`) {
          section.className = 'section active';
        } else {
          section.className = 'section inactive';
        }
      }
      for (let slide of document.querySelectorAll('.slide')) {
        if (slide.id === `slide-${activeSlide[0]}-${activeSlide[1]}`) {
          slide.className = 'slide active';
        } else {
          slide.className = 'slide inactive';
        }
      }
    }

    const updatePageArrows = () => {
      if (slideCount.length === 1) {
        arrowLeft.style.opacity = "0";
        arrowRight.style.opacity = "0";
      } else {
        const progressSections = (activeSlide[0] - 1) / (slideCount.length - 1);
        arrowLeft.style.opacity = progressSections.toString();
        arrowRight.style.opacity = (1 - progressSections).toString();
      }
      const slidesInActiveSection = slideCount[activeSlide[0] - 1]
      if (slidesInActiveSection === 1) {
        arrowUp.style.opacity = "0";
        arrowDown.style.opacity = "0";
      } else {
        const progressSlides = (activeSlide[1] - 1) / (slidesInActiveSection - 1);
        arrowUp.style.opacity = progressSlides.toString();
        arrowDown.style.opacity = (1 - progressSlides).toString();
      }
    }

    /**
     * Activate a slide if it exists, else do nothing
    */
    const activateSlideSafe = (sectionIndex, slideIndex) => {
      if (1 <= sectionIndex && sectionIndex <= slideCount.length && 1 <= slideIndex && slideIndex <= slideCount[sectionIndex - 1]) {
        activeSlide = [sectionIndex, slideIndex];
        updateVisible();
        updatePageArrows();
        scrolltoActiveSlide();
      }
    }

    const activateSlideNextSafe = () => {
      if (activeSlide[1] === slideCount[activeSlide[0] - 1]) {
        activateSlideSafe(activeSlide[0] + 1, 1);
      } else {
        activateSlideSafe(activeSlide[0], activeSlide[1] + 1);
      }
    }

    const activateSlideRightSafe = () => {
      activateSlideSafe(activeSlide[0] + 1, 1);
    }

    const activateSlideLeftSafe = () => {
      activateSlideSafe(activeSlide[0] - 1, 1);
    }

    const activateSlideDownSafe = () => {
      activateSlideSafe(activeSlide[0], activeSlide[1] + 1);
    }

    const activateSlideUpSafe = () => {
      activateSlideSafe(activeSlide[0], activeSlide[1] - 1);
    }

    const scrolltoActiveSlide = () => {
      const slideId = `#slide-${activeSlide[0]}-${activeSlide[1]}`;
      if (presenterWindow) {
        const activeSlide = presenterWindow.document.querySelector(slideId);
        if (activeSlide) {
          activeSlide.scrollIntoView();
        }
      }
    }

    const addKeyControls = () => {
      document.querySelector('body').addEventListener('keydown', event => {
        if (event.key === 'p') {
          const canvasContent = document.querySelector('#canvas-content').innerHTML;
          presenterWindow = window.open(document.URL, '_blank');
          presenterWindow.onload = () => {
            presenterWindow.document.querySelector('body').innerHTML = canvasContent;
          }
        }
        if (event.key === 'ArrowRight') {
          activateSlideRightSafe();
        } else if (event.key === 'ArrowLeft') {
          activateSlideLeftSafe();
        } else if (event.key === 'ArrowDown') {
          activateSlideDownSafe();
        } else if (event.key === 'ArrowUp') {
          activateSlideUpSafe();
        } else if (event.key === 'Enter') {
          activateSlideNextSafe();
        }
      });
    }

    const addSwipeControls = () => {

      const distance = 100;

      let startPos;
      let handled;

      document.addEventListener('touchstart', event => {
        startPos = event.touches[0];
        handled = false;
      });

      document.addEventListener('touchmove', event => {
        if (!handled) {
          let currentPos = event.touches[0];
          const xDiff = currentPos.clientX - startPos.clientX;
          const yDiff = currentPos.clientY - startPos.clientY;
          if (Math.abs(xDiff) > 2*Math.abs(yDiff) ||
              Math.abs(yDiff) > 2*Math.abs(xDiff)) {
            if (xDiff > distance) {
              activateSlideLeftSafe();
              handled = true;
            } else if (xDiff < -distance) {
              activateSlideRightSafe();
              handled = true;
            } else if (yDiff > distance) {
              activateSlideUpSafe();
              handled = true;
            } else if (yDiff < -distance) {
              activateSlideDownSafe();
              handled = true;
            }
          }
        }
      });
    }

    init();

  </script>
</body>

</html>