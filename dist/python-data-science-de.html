<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Python & Data Science</title>
  <style>/*

Original highlight.js style (c) Ivan Sagalaev <maniac@softwaremaniacs.org>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #F0F0F0;
}


/* Base color: saturation 0; */

.hljs,
.hljs-subst {
  color: #444;
}

.hljs-comment {
  color: #888888;
}

.hljs-keyword,
.hljs-attribute,
.hljs-selector-tag,
.hljs-meta-keyword,
.hljs-doctag,
.hljs-name {
  font-weight: bold;
}


/* User color: hue: 0 */

.hljs-type,
.hljs-string,
.hljs-number,
.hljs-selector-id,
.hljs-selector-class,
.hljs-quote,
.hljs-template-tag,
.hljs-deletion {
  color: #880000;
}

.hljs-title,
.hljs-section {
  color: #880000;
  font-weight: bold;
}

.hljs-regexp,
.hljs-symbol,
.hljs-variable,
.hljs-template-variable,
.hljs-link,
.hljs-selector-attr,
.hljs-selector-pseudo {
  color: #BC6060;
}


/* Language color: hue: 90; */

.hljs-literal {
  color: #78A960;
}

.hljs-built_in,
.hljs-bullet,
.hljs-code,
.hljs-addition {
  color: #397300;
}


/* Meta color: hue: 200 */

.hljs-meta {
  color: #1f7199;
}

.hljs-meta-string {
  color: #4d99bf;
}


/* Misc effects */

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}
</style>
</head>

<body>
  <div id="canvas">
    <div id="no-script">
      Could not execute modern JavaScript code. Please switch to a modern browser,
      e.g. the most recent version of Firefox, Chrome or Edge and enable JavaScript.
    </div>
    <div id="canvas-content">

      <section class="section" id="section-1"><section class="slide" id="slide-1-1">
        <h1 id="title">Python & Data Science</h1>

      </section><section class="slide" id="slide-1-2">
        <h2 id="präsentation-und-code">Präsentation und Code</h2>
<p>Präsentationen verfügbar unter: <a href="https://karuga.eu/courses-presentations">https://karuga.eu/courses-presentations</a></p>
<p>Code verfügbar unter: <a href="https://github.com/marko-knoebl/courses-code">https://github.com/marko-knoebl/courses-code</a></p>

      </section><section class="slide" id="slide-1-3">
        <h2 id="ihr-trainer">Ihr Trainer</h2>
<p>Marko Knöbl</p>
<ul>
<li>Frontend Web-Entwicklung<ul>
<li>JavaScript</li>
<li>React, Angular</li>
</ul>
</li>
<li>Programmierung<ul>
<li>Python, JavaScript</li>
</ul>
</li>
</ul>

      </section><section class="slide" id="slide-1-4">
        <h2 id="vorstellung-der-teilnehmer">Vorstellung der Teilnehmer</h2>
<ul>
<li>Name</li>
<li>Firma</li>
<li>Aktuelle Projekte</li>
<li>Grund der Schulung</li>
<li>Vorkenntnisse</li>
<li>Erwartungen / Wünsche</li>
</ul>

      </section><section class="slide" id="slide-1-5">
        <h2 id="organisatorisches">Organisatorisches</h2>
<ul>
<li>Kursdauer</li>
<li>Pausen</li>
<li>Mittagessen</li>
<li>Unterlagen</li>
<li>Fragen, Feedback? - Jederzeit erwünscht</li>
</ul>

      </section></section><section class="section" id="section-2"><section class="slide" id="slide-2-1">
        <h1 id="pakete">Pakete</h1>

      </section><section class="slide" id="slide-2-2">
        <h2 id="python-pakete-für-data-science">Python Pakete für Data Science</h2>
<ul>
<li><em>Jupyter</em> &amp; <em>IPython</em>: interaktive Python Umgebungen</li>
<li><em>NumPy</em>: Bibliothek zum effizienten Verarbeiten numerischer Daten</li>
<li><em>Pandas</em>: Bibliothek zur Datenanalyse, basiert auf NumPy</li>
<li><em>Matplotlib</em>: Bibliothek zur Datenvisualisierung</li>
<li><em>Scikit-Learn</em>: Bibliothek für Machine Learning, basiert auf NumPy</li>
</ul>

      </section><section class="slide" id="slide-2-3">
        <h2 id="anaconda">Anaconda</h2>
<p><em>Anaconda</em> = Python Distribution, die viele vorinstallierte Pakete und Entwicklerwerkzeuge enthält</p>
<p>Benötigt ~3GB Platz auf der Festplatte</p>

      </section><section class="slide" id="slide-2-4">
        <h2 id="installation-von-anaconda">Installation von Anaconda</h2>
<p>Download von <a href="https://www.anaconda.com/distribution/">https://www.anaconda.com/distribution/</a></p>
<p>(Achte auf die Wahl des richtigen Betriebssystems)</p>
<p>Unter Windows sollte der Installationspfad keine Leerzeichen enthalten (Empfehlung: <code>C:/anaconda</code>) - siehe <a href="https://docs.anaconda.com/anaconda/user-guide/faq/#distribution-faq-windows-folder">https://docs.anaconda.com/anaconda/user-guide/faq/#distribution-faq-windows-folder</a></p>

      </section><section class="slide" id="slide-2-5">
        <h2 id="conda">Conda</h2>
<p><em>Conda</em> = Environment- und Paketmanager</p>
<p>Erlaubt das Installieren verschiedener Versionen von Python, von Python-Paketen und anderen Abhängigkeiten - insbesondere hilfreich für externe Libraries, die nicht in Python geschrieben sind und kompiliert werden müssen</p>

      </section><section class="slide" id="slide-2-6">
        <h2 id="pyodide">Pyodide</h2>
<p><em>Pyodide</em> = Python Distribution, die direkt im Browser ausgeführt wird (via <em>WebAssembly</em>)</p>

      </section></section><section class="section" id="section-3"><section class="slide" id="slide-3-1">
        <h1 id="jupyter--ipython">Jupyter &amp; IPython</h1>

      </section><section class="slide" id="slide-3-2">
        <h2 id="ipython">IPython</h2>
<p>IPython = Fortgeschrittene interaktive Python Konsole, beinhaltet u.a. Autovervollständigung</p>

      </section><section class="slide" id="slide-3-3">
        <h2 id="jupyter-notebooks">Jupyter Notebooks</h2>
<p>Jupyter Notebook = Interaktive Python-Umgebung, beinhaltet IPython</p>
<p>Jupyter läuft Browser-basiert; das Backend kann auf dem lokalen Rechner oder auf einem Server laufen</p>

      </section><section class="slide" id="slide-3-4">
        <h2 id="jupyter-notebooks---online">Jupyter Notebooks - online</h2>
<p>Jupyter online ausprobieren:</p>
<h3 id="google-colab-google-account-benötigt">Google Colab (Google Account benötigt)</h3>
<ul>
<li>Gehe zu <a href="https://colab.research.google.com">https://colab.research.google.com</a></li>
<li>Wähle <em>File</em> - <em>New Python 3 Notebook</em></li>
</ul>
<h3 id="binder-begrenzte-sessions">Binder (begrenzte Sessions)</h3>
<ul>
<li>Gehe zu <a href="https://jupyter.org/try">https://jupyter.org/try</a></li>
<li><em>Try Classic Notebook</em> auswählen</li>
<li>warten ...</li>
<li><em>File</em> - <em>New Notebook</em> - <em>Python 3</em></li>
</ul>

      </section><section class="slide" id="slide-3-5">
        <h2 id="jupyter-notebooks---lokal">Jupyter Notebooks - lokal</h2>
<p>Starten: Eintrag <em>Jupyter Notebook</em> im Startmenü / Befeh <code>jupyter notebook</code> im Terminal</p>
<p>Stoppen: <em>Quit</em> im rechten oberen Eck der Ordneransicht (üblicherweise unter <a href="http://localhost:8888/tree">http://localhost:8888/tree</a>)</p>

      </section><section class="slide" id="slide-3-6">
        <h2 id="notebook-dateien">Notebook Dateien</h2>
<p>Anlegen neuer Notebook Dateien via <em>new</em> - <em>Notebook: Python 3</em></p>
<p>Speicherung unter <em>notebook.ipynb</em></p>
<p><em>Ipynb</em>: Dateiformat, das Python Code, Ausgaben und Dokumentation/Notizen beinhalten kann</p>

      </section><section class="slide" id="slide-3-7">
        <h2 id="code-schreiben-und-ausführen">Code schreiben und ausführen</h2>
<p>Code in eine Zelle schreiben, z.B.</p>
<pre><code class="language-py"><span class="hljs-keyword">import</span> time
time.sleep(<span class="hljs-number">3</span>)
<span class="hljs-string">"hello"</span></code></pre>
<p>dann <em>Shift</em> + <em>Enter</em> drücken</p>

      </section><section class="slide" id="slide-3-8">
        <h2 id="code-schreiben-und-ausführen">Code schreiben und ausführen</h2>
<p>In IPython gibt es nummerierte Eingaben, z.B. <code>In [1]</code></p>
<p>Während eine Eingabe ausgewertet wird, wird <code>In [*]</code> angezeigt</p>
<p>Wenn das letzte Statement in einer Zelle einen Wert ergibt, wird dies als Ausgabe angezeigt</p>
<p>Um das Notebook neu zu starten und alle Zellen neu auszuwerten, drücke ⏩</p>

      </section><section class="slide" id="slide-3-9">
        <h2 id="code-schreiben-und-ausführen">Code schreiben und ausführen</h2>
<p>Auf die letzte Ausgabe zugreifen:</p>
<pre><code class="language-py">print(_ * <span class="hljs-number">3</span>)</code></pre>

      </section><section class="slide" id="slide-3-10">
        <h2 id="dokumentation-via-markdown">Dokumentation via Markdown</h2>
<p>Wir können Dokumentation über die standardisierte Sprache <em>Markdown</em> hinzufügen:</p>
<p>Wir ändern das Dropdown von <em>Code</em> auf <em>Markdown</em> und versuchen den folgenden Code:</p>
<pre><code class="language-md"><span class="hljs-section"># Heading</span>

<span class="hljs-bullet">- </span>item 1
<span class="hljs-bullet">- </span>item 2</code></pre>
<p>Zelle ausführen, um das Resultat anzuzeigen, doppelklicken zum erneuten Editieren</p>
<p><a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">Markdown Cheatsheet</a></p>

      </section><section class="slide" id="slide-3-11">
        <h2 id="dokumentation">Dokumentation</h2>
<p>Dokumentation zu Funktion / Klasse / Modul / ... in einer Python Konsole anzeigen:</p>
<pre><code class="language-py">help(str)</code></pre>
<p>(Navigieren durch lange Ausgaben via <em>Enter</em>, Beenden via <em>Q</em>)</p>
<p>Shortcut in IPython / Jupyter:</p>
<pre><code class="language-ipython">str?</code></pre>

      </section><section class="slide" id="slide-3-12">
        <h2 id="tab-vervollständigung-und-wildcard-ausdrücke">Tab-Vervollständigung und Wildcard-Ausdrücke</h2>
<pre><code class="language-ipython">*Error?</code></pre>

      </section><section class="slide" id="slide-3-13">
        <h2 id="terminal-befehle-ausführen">Terminal-Befehle ausführen</h2>
<p>IPython beinhaltet direkten Zugriff auf viele Terminal-Befehle, z.B. <code>ls</code>, <code>cd</code>, ...</p>
<p>Wir können beliebige Terminal-Befehle ausführen, indem wir ein <code>!</code> davor setzen</p>

      </section></section><section class="section" id="section-4"><section class="slide" id="slide-4-1">
        <h1 id="numpy">NumPy</h1>

      </section><section class="slide" id="slide-4-2">
        <h2 id="numpy">NumPy</h2>
<p>Library zur effizienten Datenverarbeitung</p>
<p>Daten sind in mehrdimensionalen Arrays von Zahlen gespeichert, die resourcenschonend umgesetzt sind:</p>
<ul>
<li>kleinerer Speicherverbrauch als z.B. Listen von Zahlen in Python</li>
<li>deutlich schnelleres Ausführen von z.B. elementweiser Addition zweier Arrays</li>
</ul>
<p>Daten können z.B. Bilder, Tondateien, Messwerte und vieles anderes repräsentieren</p>

      </section><section class="slide" id="slide-4-3">
        <h2 id="importieren-von-numpy">Importieren von NumPy</h2>
<p>oft verkürzt als:</p>
<pre><code class="language-python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</code></pre>

      </section><section class="slide" id="slide-4-4">
        <h2 id="arrays">Arrays</h2>
<p>Erstellen eines 2-dimensionalen Arrays:</p>
<pre><code class="language-py">a2d = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>]])</code></pre>
<p>Ausgabe:</p>
<pre><code class="language-py">array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
       [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>],
       [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>]])</code></pre>

      </section><section class="slide" id="slide-4-5">
        <h2 id="arrays">Arrays</h2>
<p>Erstellen eines 3-dimensionalen Arrays:</p>
<pre><code class="language-py">a3d = np.array([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]], [[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]]])</code></pre>
<p>Ausgabe:</p>
<pre><code class="language-py">array([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
        [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]],

       [[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>],
        [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]]])</code></pre>

      </section><section class="slide" id="slide-4-6">
        <h2 id="arrays">Arrays</h2>
<p>NumPy Arrays vs Python Listen:</p>
<p>Arrays sind im Hintergrund in C implementiert, die numerischen Einträge (z.B. Integer) sind keine Python-Objekte und damit resourcenschonender.</p>

      </section><section class="slide" id="slide-4-7">
        <h2 id="arrays">Arrays</h2>
<p>NumPy Arrays vs Python Listen:</p>
<pre><code class="language-py"><span class="hljs-comment"># Python - Listen (mit Verweisen auf andere Integer)</span>
list_a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
list_b = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]

<span class="hljs-comment"># NumPy - Array -</span>
<span class="hljs-comment"># Daten sind hierin enthalten, ohne auf Python-Integer</span>
<span class="hljs-comment"># zu verweisen</span>
array_a = numpy.array(list_a)
array_b = numpy.array(list_b)

<span class="hljs-comment"># sehr schnell (da in C implementiert)</span>
array_a + array_b</code></pre>

      </section><section class="slide" id="slide-4-8">
        <h2 id="array-shape">Array Shape</h2>
<p>Wir können folgendes abfragen:</p>
<ul>
<li><code>a3d.ndim</code>: 3</li>
<li><code>a3d.shape</code>: (2, 2, 2)</li>
<li><code>a3d.size</code>: 8</li>
</ul>

      </section></section><section class="section" id="section-5"><section class="slide" id="slide-5-1">
        <h1 id="arrays-erstellen">Arrays erstellen</h1>

      </section><section class="slide" id="slide-5-2">
        <h2 id="arrays-erstellen">Arrays erstellen</h2>
<p>Ein Array der Größe 2x6, gefüllt mit Nullen:</p>
<pre><code class="language-py">np.zeros((<span class="hljs-number">2</span>, <span class="hljs-number">6</span>))</code></pre>
<p>oder</p>
<pre><code class="language-py">np.full((<span class="hljs-number">2</span>, <span class="hljs-number">6</span>), <span class="hljs-number">0</span>)</code></pre>
<p>Ein 3x3 Array mit Zufallswerten:</p>
<pre><code class="language-py">np.random.random(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)</code></pre>

      </section><section class="slide" id="slide-5-3">
        <h2 id="arrays-erstellen">Arrays erstellen</h2>
<p>Die Folge <em>0.0, 0.5, 1.0, 1.5</em>:</p>
<pre><code class="language-py"><span class="hljs-comment"># fixed step width (0.5)</span>
a = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0.5</span>)
<span class="hljs-comment"># fixed number of entries (4)</span>
b = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">4</span>)</code></pre>

      </section></section><section class="section" id="section-6"><section class="slide" id="slide-6-1">
        <h1 id="operationen-auf-arrays">Operationen auf Arrays</h1>

      </section><section class="slide" id="slide-6-2">
        <h2 id="operationen-auf-arrays">Operationen auf Arrays</h2>
<p>Auswählen von Einträgen:</p>
<pre><code class="language-py">a2d[<span class="hljs-number">0</span>] <span class="hljs-comment"># [1, 2, 3]</span>
a2d[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>] <span class="hljs-comment"># 2</span>
a2d[<span class="hljs-number">0</span>, :] <span class="hljs-comment"># [1, 2, 3]</span>
a2d[:, <span class="hljs-number">0</span>] <span class="hljs-comment"># [1, 2, 3]</span></code></pre>

      </section><section class="slide" id="slide-6-3">
        <h2 id="operationen-auf-arrays">Operationen auf Arrays</h2>
<p>Auswählen von Einträgen:</p>
<pre><code class="language-py">a2d[<span class="hljs-number">1</span>:, <span class="hljs-number">1</span>:] <span class="hljs-comment"># [[4, 6], [6, 9]]</span>
a2d[<span class="hljs-number">1</span>, ::<span class="hljs-number">-1</span>] <span class="hljs-comment"># [3, 2, 1]</span></code></pre>

      </section><section class="slide" id="slide-6-4">
        <h2 id="operationen-auf-arrays">Operationen auf Arrays</h2>
<p>Operatoren werden elementweise angewendet:</p>
<pre><code class="language-py">a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
b = np.array([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>])

print(-a)
<span class="hljs-comment"># np.array([-1, -2, -3])</span>
print(a + b)
<span class="hljs-comment"># np.array([3, 4, 5])</span>
print(a * b)
<span class="hljs-comment"># np.array([2, 4, 6])</span></code></pre>

      </section><section class="slide" id="slide-6-5">
        <h2 id="operationen-auf-arrays">Operationen auf Arrays</h2>
<p>Auch mit einzelnen Zahlen möglich (broadcasting):</p>
<pre><code class="language-py">a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])

print(a + <span class="hljs-number">1</span>)
<span class="hljs-comment"># np.array([2, 3, 4])</span></code></pre>
<p>Einige Konstanten sind direkt in NumPy verfügbar:</p>
<pre><code class="language-py">print(a + np.pi)
print(a + np.e)</code></pre>

      </section><section class="slide" id="slide-6-6">
        <h2 id="operationen-auf-arrays">Operationen auf Arrays</h2>
<p>Elementweises Vergleichen von Arrays:</p>
<pre><code class="language-py">a &lt; b
<span class="hljs-comment"># np.array([True, False, False])</span>
a == b
<span class="hljs-comment"># np.array([False, True, False])</span></code></pre>
<p>Achtung: <code>a == b</code> kann nicht sinnvoll in if-Abfragen verwendet werden - verwende <code>np.array_equal(a, b)</code>.</p>

      </section><section class="slide" id="slide-6-7">
        <h2 id="operationen-auf-arrays">Operationen auf Arrays</h2>
<p>Filtern von Arrays (z.B. beschränken auf positive Einträge):</p>
<pre><code class="language-py">a = np.array([[<span class="hljs-number">-1</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">-2</span>, <span class="hljs-number">1</span>]])
a_is_pos = a &gt; <span class="hljs-number">0</span> <span class="hljs-comment"># array([[False, True], [False, True]])</span>
a_pos = a[a_is_pos] <span class="hljs-comment"># array[3, 1]</span></code></pre>
<p>Kurzform:</p>
<pre><code class="language-py">a_pos = a[a &gt; <span class="hljs-number">0</span>]</code></pre>

      </section><section class="slide" id="slide-6-8">
        <h2 id="operationen-auf-arrays">Operationen auf Arrays</h2>
<p>NumPy bietet spezielle Funktionen, die elementweise angewendet werden:</p>
<pre><code class="language-py">a = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])

print(np.sin(a)) <span class="hljs-comment"># [0.0, 0.84147098, 0.9... ]</span>
print(np.sqrt(a)) <span class="hljs-comment"># [0.0, 1.0, 1.414... ]</span></code></pre>

      </section><section class="slide" id="slide-6-9">
        <h2 id="operationen-auf-arrays">Operationen auf Arrays</h2>
<p>Elementweise Funktionen:</p>
<ul>
<li><code>abs</code></li>
<li><code>sin</code></li>
<li><code>cos</code></li>
<li><code>sqrt</code></li>
<li><code>exp</code></li>
<li><code>log</code></li>
<li><code>log10</code></li>
<li>...</li>
</ul>

      </section><section class="slide" id="slide-6-10">
        <h2 id="operationen-auf-arrays">Operationen auf Arrays</h2>
<p><em>Aggregationen</em> berechnen beispielsweise Werte zu jeder Zeile / jeder Spalte oder zu einem ganzen Array</p>
<ul>
<li>Gesamtsumme: <code>np.sum(a2d)</code></li>
<li>Summe in Richtung der Spalten: <code>np.sum(a2d, axis=0)</code></li>
<li>Summe in Richtung der Zeilen: <code>np.sum(a2d, axis=1)</code></li>
</ul>

      </section><section class="slide" id="slide-6-11">
        <h2 id="operationen-auf-arrays">Operationen auf Arrays</h2>
<p>Aggregationen:</p>
<ul>
<li><code>sum</code></li>
<li><code>min</code></li>
<li><code>max</code></li>
<li><code>std</code></li>
<li><code>percentile</code></li>
</ul>

      </section><section class="slide" id="slide-6-12">
        <h2 id="übungen">Übungen</h2>
<p>(siehe nächste Slides)</p>
<ul>
<li>Preise und Mengen -&gt; Gesamtpreis</li>
<li>Schwerpunkt eines Dreiecks</li>
<li>Sinus- und Kosinusfunktion - Wertetabelle</li>
</ul>

      </section><section class="slide" id="slide-6-13">
        <h2 id="übungen">Übungen</h2>
<p>Gegeben sind ein Array von Preisen und ein Array von gekauften Mengen. Bestimme den Gesamtpreis:</p>
<pre><code class="language-py">prices = np.array([<span class="hljs-number">3.99</span>, <span class="hljs-number">4.99</span>, <span class="hljs-number">3.99</span>, <span class="hljs-number">12.99</span>])
<span class="hljs-comment"># buying the first item 3 times and the last item 2 times</span>
quantities = np.array([<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>])

<span class="hljs-comment"># solution: 37.95</span></code></pre>

      </section><section class="slide" id="slide-6-14">
        <h2 id="übungen">Übungen</h2>
<p>Gegeben sind die Koordinaten von Eckpunkten eines Dreiecks (2D oder 3D). Bestimme den Schwerpunkt (arithmetisches Mittel der Eckpunkte).</p>
<pre><code class="language-py">a = np.array([<span class="hljs-number">5</span>, <span class="hljs-number">1</span>])
b = np.array([<span class="hljs-number">6</span>, <span class="hljs-number">8</span>])
c = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>])

<span class="hljs-comment"># solution: [4, 4]</span></code></pre>

      </section><section class="slide" id="slide-6-15">
        <h2 id="übungen">Übungen</h2>
<p>Erstelle eine Wertetabelle für Sinus- und Kosinusfunktion im Intervall von 0 bis 2*pi.</p>
<p>Resultat:</p>
<pre><code class="language-py"><span class="hljs-comment"># x, sin(x), cos(x)</span>
np.array([[<span class="hljs-number">0.0</span>, <span class="hljs-number">0.01</span>, <span class="hljs-number">0.02</span>, ...],
          [<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0099998</span>, <span class="hljs-number">0.99995</span>, ...],
          [<span class="hljs-number">1.0</span>, <span class="hljs-number">0.99995</span>, <span class="hljs-number">0.99980</span>, ...]])</code></pre>
<p>Überprüfe anhand der Daten, ob näherungsweise gilt: <em>sin(x)^2 + cos(x)^2 == 1</em></p>

      </section></section><section class="section" id="section-7"><section class="slide" id="slide-7-1">
        <h1 id="array-typen">Array Typen</h1>

      </section><section class="slide" id="slide-7-2">
        <h2 id="array-typen">Array Typen</h2>
<p>Jedes Array kann nur Daten eines Typs enthalten (z.B. nur 64-bit floats oder nur bytes)</p>

      </section><section class="slide" id="slide-7-3">
        <h2 id="array-typen">Array Typen</h2>
<p>Jedes Array hat einen vorgegebenen Datentyp für alle Einträge</p>
<pre><code class="language-py">a = np.array([<span class="hljs-number">1</span>])
a.dtype <span class="hljs-comment"># int32</span>
b = np.array([<span class="hljs-number">1.0</span>])
b.dtype <span class="hljs-comment"># float64</span>
c = np.array([<span class="hljs-string">'abc'</span>])
c.dtype <span class="hljs-comment"># &lt;U3</span>
d = np.array([<span class="hljs-string">b'abc'</span>])
d.dtype <span class="hljs-comment"># |S3</span></code></pre>

      </section><section class="slide" id="slide-7-4">
        <h2 id="array-typen">Array Typen</h2>
<p>Typen können explizit angegeben werden:</p>
<pre><code class="language-py">a = np.array([<span class="hljs-number">1</span>], dtype=<span class="hljs-string">'int64'</span>)
b = np.array([<span class="hljs-number">1</span>], dtype=<span class="hljs-string">'uint8'</span>)</code></pre>
<p>Typen werden wenn möglich automatisch umgewandelt:</p>
<pre><code class="language-py">c = a + b
c.dtype <span class="hljs-comment"># int64</span></code></pre>

      </section><section class="slide" id="slide-7-5">
        <h2 id="array-typen">Array Typen</h2>
<p>wichtige Typen:</p>
<ul>
<li><em>bool</em> / <em>bool_</em> (Speicherverbrauch 8 Bit)</li>
<li><em>int8</em>, <em>int16</em>, <em>int32</em>, <em>int64</em></li>
<li><em>uint8</em>, <em>uint16</em>, <em>uint32</em>, <em>uint64</em></li>
<li><em>float16</em>, <em>float32</em>, <em>float64</em></li>
</ul>

      </section><section class="slide" id="slide-7-6">
        <h2 id="overflow">Overflow</h2>
<p>Achtung bei zu großen / zu kleinen Werten</p>
<p>Der Typ <code>int8</code> erlaubt nur Werte im Bereich <code>-128</code> bis <code>+127</code></p>
<pre><code class="language-py">np.array([<span class="hljs-number">127</span>, <span class="hljs-number">128</span>, <span class="hljs-number">129</span>], dtype=<span class="hljs-string">"int8"</span>)</code></pre>
<p>Output:</p>
<pre><code class="language-py">array([<span class="hljs-number">127</span>, <span class="hljs-number">-128</span>, <span class="hljs-number">-127</span>])</code></pre>

      </section></section><section class="section" id="section-8"><section class="slide" id="slide-8-1">
        <h1 id="plotting">Plotting</h1>
<h3 id="grafische-darstellung-von-daten">Grafische Darstellung von Daten</h3>

      </section><section class="slide" id="slide-8-2">
        <h2 id="plotting">Plotting</h2>
<p>Grundlegende (low-level) Library für Plotting: <em>matplotlib</em></p>
<p>Abstrahierende Interfaces zu grundlegenden matplotlib Funktionen:</p>
<ul>
<li><em>pyplot</em> (enthalten in matplotlib, ähnlich zum matlab Plotinterface)</li>
<li><em>pandas</em> Plotfunktionen</li>
<li><em>seaborn</em></li>
</ul>

      </section><section class="slide" id="slide-8-3">
        <h2 id="einfacher-plot-mit-pyplot">Einfacher Plot mit pyplot</h2>
<pre><code class="language-py"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt

x = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])

y1 = x*<span class="hljs-number">2</span>
y2 = x**<span class="hljs-number">2</span>

plt.plot(x, y1)
plt.plot(x, y2)

<span class="hljs-comment"># plt.show is not needed in Jupyter</span>
plt.show()</code></pre>

      </section><section class="slide" id="slide-8-4">
        <h2 id="einfacher-plot-mit-pandas">Einfacher Plot mit pandas</h2>
<pre><code class="language-py"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

x = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])

data = pd.DataFrame({
    <span class="hljs-string">"y1"</span>: x*<span class="hljs-number">2</span>,
    <span class="hljs-string">"y2"</span>: x**<span class="hljs-number">2</span>
})

data.plot.line()

<span class="hljs-comment"># plt.show is not needed in Jupyter</span>
plt.show()</code></pre>

      </section><section class="slide" id="slide-8-5">
        <h2 id="übung">Übung</h2>
<p>Erstelle einen Plot, der die Sinus- und Kosinusfunktion im Intervall von <em>0</em> bis <em>2π</em> zeigt.</p>

      </section><section class="slide" id="slide-8-6">
        <h2 id="übung">Übung</h2>
<pre><code class="language-py">x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>*<span class="hljs-number">3.1415</span>, <span class="hljs-number">200</span>)

plt.plot(x, np.sin(x))
plt.plot(x, np.cos(x))</code></pre>
<pre><code class="language-py">x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>*<span class="hljs-number">3.1415</span>, <span class="hljs-number">200</span>)

df = pd.DataFrame({<span class="hljs-string">"sin"</span>: np.sin(x), <span class="hljs-string">"cos"</span>: np.cos(x)}, index=x)

df.plot.line()</code></pre>

      </section><section class="slide" id="slide-8-7">
        <h2 id="übungen">Übungen</h2>
<p>Zeichne eine Gauß&#39;sche Glockenkurve</p>

      </section></section><section class="section" id="section-9"><section class="slide" id="slide-9-1">
        <h1 id="konfiguration-und-styling">Konfiguration und Styling</h1>

      </section><section class="slide" id="slide-9-2">
        <h2 id="stile">Stile</h2>
<p>Vorgefertigte Stylesheets verwendbar mittels:</p>
<pre><code class="language-py">plt.style.use(<span class="hljs-string">"stylename"</span>)</code></pre>
<p>Für Demos verfügbarer Stile siehe:</p>
<p><a href="https://matplotlib.org/3.1.0/gallery/style_sheets/style_sheets_reference.html">https://matplotlib.org/3.1.0/gallery/style_sheets/style_sheets_reference.html</a></p>

      </section><section class="slide" id="slide-9-3">
        <h2 id="stile-von-graphen">Stile von Graphen</h2>
<p>Kurzformen:</p>
<pre><code class="language-py">plt.plot(x, y, <span class="hljs-string">"gx--"</span>)</code></pre>
<p>Langform:</p>
<pre><code class="language-py">plt.plot(x, y, color=<span class="hljs-string">"green"</span>, linestyle=<span class="hljs-string">"dashed"</span>, marker=<span class="hljs-string">"x"</span>)</code></pre>
<p>In der Langform sind genauere Farb- und Größenangaben möglich</p>

      </section><section class="slide" id="slide-9-4">
        <h2 id="stile-von-graphen">Stile von Graphen</h2>
<p>mögliche Farbangaben:</p>
<ul>
<li>Farbname (<code>green</code> / <code>lighblue</code> / ...)</li>
<li>Kurzname (<code>r</code> / <code>g</code> / <code>b</code> / <code>c</code> / <code>m</code> / <code>y</code> / <code>k</code>)</li>
<li>Hex-Code (z.B. <code>#FFAA00</code>)</li>
<li>RGB-Tupel (z.B. <code>(1, 0.7, 0)</code>)</li>
</ul>

      </section><section class="slide" id="slide-9-5">
        <h2 id="stile-von-graphen">Stile von Graphen</h2>
<p>mögliche Lininenstile:</p>
<ul>
<li><code>&quot;&quot;</code> (<em>none</em>)</li>
<li><code>&quot;-&quot;</code> (<em>solid</em>)</li>
<li><code>&quot;--&quot;</code> (<em>dashed</em>)</li>
<li><code>&quot;:&quot;</code> (<em>dotted</em>)</li>
<li><code>&quot;-.&quot;</code> (<em>dashdot</em>)</li>
</ul>

      </section><section class="slide" id="slide-9-6">
        <h2 id="stile-von-graphen">Stile von Graphen</h2>
<p>mögliche Marker:</p>
<ul>
<li><code>&quot;&quot;</code> (keine)</li>
<li><code>&quot;,&quot;</code> (kleiner Punkt)</li>
<li><code>&quot;.&quot;</code> (mittelgroßer Punkt)</li>
<li><code>&quot;o&quot;</code> (großer Punkt)</li>
<li><code>&quot;s&quot;</code> (Quadrat)</li>
<li><code>&quot;x&quot;</code></li>
<li><code>&quot;+&quot;</code></li>
<li>...</li>
</ul>

      </section><section class="slide" id="slide-9-7">
        <h2 id="stile-von-graphen">Stile von Graphen</h2>
<p>wichtige Parameter:</p>
<ul>
<li><code>color</code></li>
<li><code>linestyle</code></li>
<li><code>linewidth</code></li>
<li><code>marker</code></li>
<li><code>markersize</code></li>
</ul>

      </section><section class="slide" id="slide-9-8">
        <h2 id="label">Label</h2>
<ul>
<li><code>plt.title(&quot;Trigonometric functions&quot;)</code></li>
<li><code>plt.xlabel(&quot;x (radians)&quot;)</code></li>
<li><code>plt.ylabel(&quot;y&quot;)</code></li>
</ul>

      </section><section class="slide" id="slide-9-9">
        <h2 id="label">Label</h2>
<p>Label für verschiedene Funktionen:</p>
<pre><code class="language-py">plt.plot(x, np.sin(x), label=<span class="hljs-string">'sin(x)'</span>)
plt.plot(x, np.cos(x), label=<span class="hljs-string">'cos(x)'</span>)

plt.legend()</code></pre>

      </section><section class="slide" id="slide-9-10">
        <h2 id="achsen">Achsen</h2>
<p>Achsen ausblenden:</p>
<pre><code class="language-py">plt.axis(<span class="hljs-string">"off"</span>)</code></pre>

      </section><section class="slide" id="slide-9-11">
        <h2 id="achsenlimits">Achsenlimits</h2>
<p>Ansicht einpassen (ohne Abstand zum Rand):</p>
<pre><code class="language-py">plt.axis(<span class="hljs-string">"tight"</span>)</code></pre>
<p>Bestimmten Ausschnitt anzeigen:</p>
<pre><code class="language-py">plt.axis([<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>])</code></pre>
<p>Bestimmten Ausschnitt für einzelne Achse:</p>
<pre><code class="language-py">plt.xlim(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>)</code></pre>

      </section><section class="slide" id="slide-9-12">
        <h2 id="achsenskalierung">Achsenskalierung</h2>
<p>Gleiche Einheitengröße auf beiden Achsen:</p>
<pre><code class="language-py">plt.axis(<span class="hljs-string">"equal"</span>)</code></pre>
<p>Gleiche Einheitengrößen und Beschränkung der Achsenmarkierungen auf verwendete Datenbereiche:</p>
<pre><code class="language-py">plt.axis(<span class="hljs-string">"scaled"</span>)</code></pre>

      </section><section class="slide" id="slide-9-13">
        <h2 id="gitter">Gitter</h2>
<pre><code class="language-py">plt.grid(<span class="hljs-keyword">True</span>)</code></pre>

      </section><section class="slide" id="slide-9-14">
        <h2 id="achsenmarkierungen">Achsenmarkierungen</h2>
<pre><code class="language-py">plt.yticks([<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>])
plt.xticks(np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>*np.pi, <span class="hljs-number">5</span>))</code></pre>

      </section><section class="slide" id="slide-9-15">
        <h2 id="übungen">Übungen</h2>
<ul>
<li>Sinus und Kosinus mit erweiterten Optionen</li>
<li>n-te Primzahl und Approximation via <em>n * ln(n)</em></li>
<li>Schätzung von Pi durch zufällige Punkte</li>
</ul>

      </section></section><section class="section" id="section-10"><section class="slide" id="slide-10-1">
        <h1 id="grundlegende-plots">Grundlegende Plots</h1>

      </section><section class="slide" id="slide-10-2">
        <h2 id="grundlegende-plots">Grundlegende Plots</h2>
<ul>
<li>Graph</li>
<li>Säulendiagramm</li>
<li>Scatter Plot</li>
<li>Histogram</li>
<li>Box Plot</li>
<li>Tortendiagramm</li>
</ul>

      </section><section class="slide" id="slide-10-3">
        <h2 id="graph">Graph</h2>
<p>Pyplot: <code>plt.plot(x, y)</code> / <code>plt.plot(y)</code></p>
<p>Pandas: <code>df.plot.line()</code> / <code>df.plot()</code></p>

      </section><section class="slide" id="slide-10-4">
        <h2 id="säulendiagramm">Säulendiagramm</h2>
<p>Pyplot: <code>plt.bar(x, y)</code></p>
<p>Pandas: <code>df.plot.bar()</code></p>

      </section><section class="slide" id="slide-10-5">
        <h2 id="scatter-plot">Scatter Plot</h2>
<p>Pyplot: <code>plt.plot(x, y, &quot;.&quot;)</code></p>
<p>Pyplot (fortgeschritten): <code>plt.scatter(x, y, size, color)</code></p>
<p>Pandas: <code>df.plot.scatter(x=&quot;name1&quot;, y=&quot;name2&quot;)</code></p>

      </section><section class="slide" id="slide-10-6">
        <h2 id="histogramm">Histogramm</h2>
<p>Pyplot: <code>plt.hist(x)</code></p>
<p>Pandas: <code>df.plot.hist()</code></p>

      </section><section class="slide" id="slide-10-7">
        <h2 id="box-plot">Box Plot</h2>
<p>Pyplot: <code>plt.boxplot(data)</code></p>
<p>Pandas: <code>df.plot.box()</code></p>

      </section><section class="slide" id="slide-10-8">
        <h2 id="tortendiagramm">Tortendiagramm</h2>
<p>Pyplot: <code>plt.pie(x, labels=[...])</code></p>
<p>Pandas: <code>df.pie()</code></p>

      </section></section><section class="section" id="section-11"><section class="slide" id="slide-11-1">
        <h1 id="grundlegende-plots-mit-pyplot">Grundlegende Plots mit pyplot</h1>

      </section><section class="slide" id="slide-11-2">
        <h2 id="graph">Graph</h2>
<p>Graph zusammengehöriger x- und y-Werte:</p>
<pre><code class="language-py">plt.plot(x, y)</code></pre>
<p>Graph mit automatischem x (0, 1, ...):</p>
<pre><code class="language-py">plt.plot(y)</code></pre>

      </section><section class="slide" id="slide-11-3">
        <h2 id="graph">Graph</h2>
<p>Mehrere Datensätze:</p>
<pre><code class="language-py">x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]

y = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],
     [<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]

plt.plot(x, y)</code></pre>

      </section><section class="slide" id="slide-11-4">
        <h2 id="säulen--und-balkendiagramm">Säulen- und Balkendiagramm</h2>
<pre><code class="language-py">plt.bar(x, y, width=<span class="hljs-number">0.6</span>)
plt.bar(x, y, width=<span class="hljs-number">1</span>, align=<span class="hljs-string">"edge"</span>)

plt.bar(
    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
    [<span class="hljs-number">9.6</span>, <span class="hljs-number">17</span>, <span class="hljs-number">9.8</span>],
    tick_label=[<span class="hljs-string">"China"</span>, <span class="hljs-string">"Russia"</span>, <span class="hljs-string">"USA"</span>]
)

plt.barh([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">9.6</span>, <span class="hljs-number">17</span>, <span class="hljs-number">9.8</span>])</code></pre>

      </section><section class="slide" id="slide-11-5">
        <h2 id="scatter-plot">Scatter Plot</h2>
<p>Einfach:</p>
<pre><code class="language-py">plt.plot(x, y, <span class="hljs-string">"."</span>)</code></pre>
<p>Fortgeschritten:</p>
<pre><code class="language-py">plt.scatter(x, y, size, color)</code></pre>

      </section><section class="slide" id="slide-11-6">
        <h2 id="histogramm">Histogramm</h2>
<pre><code class="language-py">plt.hist(iris[:, <span class="hljs-number">2</span>], bins=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], density=<span class="hljs-keyword">True</span>)</code></pre>

      </section><section class="slide" id="slide-11-7">
        <h2 id="box-plot">Box Plot</h2>
<pre><code class="language-py">plt.boxplot(iris[:, :<span class="hljs-number">4</span>], labels=[<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>])</code></pre>

      </section><section class="slide" id="slide-11-8">
        <h2 id="tortendiagramm">Tortendiagramm</h2>
<pre><code class="language-py">plt.pie([<span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">17</span>, <span class="hljs-number">9</span>], labels=[<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>])

plt.pie([<span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">17</span>, <span class="hljs-number">9</span>], explode=[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>])</code></pre>

      </section></section><section class="section" id="section-12"><section class="slide" id="slide-12-1">
        <h1 id="figure-axes--subplots">Figure, Axes &amp; Subplots</h1>

      </section><section class="slide" id="slide-12-2">
        <h2 id="figure--axes">Figure &amp; Axes</h2>
<p>Figure = ganze Zeichnung</p>
<p>Axes = Koordinatensystem, in das Daten eingetragen werden</p>
<p>Eine Figure kann mehrere Axes-Objekte (nebeneinander, untereinander, ...) enthalten</p>

      </section><section class="slide" id="slide-12-3">
        <h2 id="figure">Figure</h2>
<p>Jede Zeichnung in <em>pyplot</em> erfolgt mittels eines <em>Figure</em>-Objekts (wird beim plotten meist automatisch erzeugt).</p>
<p>Manuelles Erstellen einer Figure mit Größe 800 x 600 px (bei 100 dpi):</p>
<pre><code class="language-py">fig = plt.figure(
    figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">6</span>),
    facecolor=<span class="hljs-string">"#eeeeee"</span>
)</code></pre>
<p>Dies wird automatisch zur aktiven Figure.</p>

      </section><section class="slide" id="slide-12-4">
        <h2 id="figure-objekte">Figure Objekte</h2>
<p>Exportieren einer Figure:</p>
<pre><code class="language-py">fig.savefig(<span class="hljs-string">"myplot.png"</span>)
fig.savefig(<span class="hljs-string">"myplot.svg"</span>)</code></pre>

      </section><section class="slide" id="slide-12-5">
        <h2 id="figure-objekte">Figure Objekte</h2>
<p>Aufgabe: Skript, das eine PNG-Datei eines Graphen der aktuellen CPU-Last erstellt und jede Sekunde aktuelisiert. (verwende hierzu das PIP-Paket <em>psutil</em>)</p>

      </section><section class="slide" id="slide-12-6">
        <h2 id="axes-objekte">Axes Objekte</h2>
<p>Das aktive <em>Axes</em>-Objekt abfragen:</p>
<pre><code class="language-py">ax = plt.gca() <span class="hljs-comment"># get current axes</span></code></pre>
<p>Die schon bekannten Methoden von <code>plt</code> verwenden im Hintergrund Methoden des aktiven <em>Axes</em> Objekts:</p>
<pre><code class="language-py">ax.plot(...)
ax.set_title(...)
ax.set_xlabel(...)
ax.legend()
ax.set_aspect(<span class="hljs-string">"equal"</span>)</code></pre>

      </section><section class="slide" id="slide-12-7">
        <h2 id="axes-objekte">Axes Objekte</h2>
<p>Aufgabe: Erstellen des Sinus- und Kosinusplots via <em>Axes</em></p>

      </section><section class="slide" id="slide-12-8">
        <h2 id="axis-und-axes">Axis und Axes</h2>
<p>Achtung unglückliche Namensvergabe:</p>
<ul>
<li><code>plt.axis</code>: z.B. zum Einstellen der Skalierung</li>
<li><code>plt.axes</code>: zum Erstellen eines neuen Koordinatensystems</li>
</ul>
<p>Eigentliche Bedeutungen aus dem Lateinischen / Englischen: <em>axis</em> = Achse, <em>axes</em> = Achsen</p>

      </section><section class="slide" id="slide-12-9">
        <h2 id="subplots">Subplots</h2>
<p>Erstellen mehrerer Axes-Objekte in einem Raster (hier: 2 Zeilen, 3 Spalten):</p>
<pre><code class="language-py">fig, ax = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)

ax0 = ax[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
ax1 = ax[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
ax5 = ax[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]</code></pre>

      </section></section><section class="section" id="section-13"><section class="slide" id="slide-13-1">
        <h1 id="erweiterte-arten-von-plots">Erweiterte Arten von Plots</h1>

      </section><section class="slide" id="slide-13-2">
        <h2 id="erweiterte-arten-von-plots">Erweiterte Arten von Plots</h2>
<ul>
<li>Datenpunkte mit mehr als 2 Features<ul>
<li>Erweiterter Scatter Plot (Größe, Farbe)</li>
<li>Scatter Matrix</li>
</ul>
</li>
<li>Plotten von z = f(x, y)<ul>
<li>Contour Plots</li>
<li>3D Plots</li>
</ul>
</li>
<li>Dichte einer Verteilung<ul>
<li>(Histogramm)</li>
<li>KDE</li>
<li>Violin Plot</li>
</ul>
</li>
<li>Dichte einer Verteilung (2D)<ul>
<li>2D Histogramm (hist2d, hexbin)</li>
<li>KDE</li>
</ul>
</li>
</ul>

      </section></section><section class="section" id="section-14"><section class="slide" id="slide-14-1">
        <h1 id="pandas">Pandas</h1>

      </section><section class="slide" id="slide-14-2">
        <h2 id="pandas">Pandas</h2>
<p><em>Pandas</em> ist eine Datenanalysebibliothek; sie beruht auf <em>NumPy</em></p>
<pre><code class="language-py"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd</code></pre>

      </section><section class="slide" id="slide-14-3">
        <h2 id="series-und-dataframe">Series und DataFrame</h2>
<ul>
<li><strong>Series</strong>: Sammlung von gleichartigen Einträgen zu bestimmten Schlüsseln (Tabellenspalte)</li>
<li><strong>DataFrame</strong>: Sammlung von zusammengehörenden <em>Series</em>-Objekten (ganze Tabelle)</li>
</ul>
<p>Beispiel:</p>
<table>
<thead>
<tr>
<th></th>
<th align="right">Area</th>
<th align="right">Population</th>
<th>Capital</th>
</tr>
</thead>
<tbody><tr>
<td>CN</td>
<td align="right">9.6</td>
<td align="right">1386</td>
<td>Beijing</td>
</tr>
<tr>
<td>RU</td>
<td align="right">17</td>
<td align="right">144</td>
<td>Moscow</td>
</tr>
<tr>
<td>US</td>
<td align="right">9.8</td>
<td align="right">327</td>
<td>Washington, D.C.</td>
</tr>
</tbody></table>

      </section><section class="slide" id="slide-14-4">
        <h2 id="series-erstellen">Series erstellen</h2>
<pre><code class="language-py">area = pd.Series({<span class="hljs-string">'CN'</span>: <span class="hljs-number">9.6</span>, <span class="hljs-string">'RU'</span>: <span class="hljs-number">17</span>, <span class="hljs-string">'US'</span>: <span class="hljs-number">9.8</span>})
population = pd.Series({<span class="hljs-string">'CN'</span>: <span class="hljs-number">1386</span>, <span class="hljs-string">'RU'</span>: <span class="hljs-number">144</span>, <span class="hljs-string">'US'</span>: <span class="hljs-number">327</span>})</code></pre>
<pre><code class="language-py">area = pd.Series([<span class="hljs-number">9.6</span>, <span class="hljs-number">17</span>, <span class="hljs-number">9.8</span>], [<span class="hljs-string">"CN"</span>, <span class="hljs-string">"RU"</span>, <span class="hljs-string">"US"</span>])
population = pd.Series([<span class="hljs-number">1386</span>, <span class="hljs-number">144</span>, <span class="hljs-number">327</span>], [<span class="hljs-string">"CN"</span>, <span class="hljs-string">"RU"</span>, <span class="hljs-string">"US"</span>])</code></pre>

      </section><section class="slide" id="slide-14-5">
        <h2 id="werte-auslesen">Werte auslesen</h2>
<pre><code class="language-py">area[<span class="hljs-number">0</span>] <span class="hljs-comment"># 9.6</span>

area[<span class="hljs-string">'CN'</span>] <span class="hljs-comment"># 9.6</span></code></pre>

      </section><section class="slide" id="slide-14-6">
        <h2 id="dataframe">DataFrame</h2>
<pre><code class="language-py">countries = pd.DataFrame({
    <span class="hljs-string">'area'</span>: area,
    <span class="hljs-string">'population'</span>: population
})</code></pre>

      </section></section><section class="section" id="section-15"><section class="slide" id="slide-15-1">
        <h1 id="daten-importieren-und-exportieren">Daten importieren und exportieren</h1>

      </section><section class="slide" id="slide-15-2">
        <h2 id="daten-importieren-und-exportieren">Daten importieren und exportieren</h2>
<p>Datenformate:</p>
<ul>
<li>CSV</li>
<li>Excel</li>
<li>JSON</li>
<li>HDF5 (effizientes Binärformat)</li>
<li>SQL tables (via <em>SQLAlchemy</em>)</li>
</ul>

      </section><section class="slide" id="slide-15-3">
        <h2 id="daten-importieren-und-exportieren">Daten importieren und exportieren</h2>
<p>Die folgenden Funktionen können Daten importieren / exportieren. Beim Importieren können Daten auch aus dem Internet gelesen werden.</p>
<p>Import: <code>pd.read_csv</code>, <code>pd.read_excel</code>, ...</p>
<p>Export: <code>df.to_csv</code>, <code>df.to_excel</code>, ...</p>

      </section><section class="slide" id="slide-15-4">
        <h2 id="csv-importieren">CSV importieren</h2>
<p>Beispiel: Euribor (Zinsen für europäische Anleihen)</p>
<pre><code class="language-py">euribor = pd.read_csv(
    <span class="hljs-string">"https://datahub.io/core/euribor/r/euribor-12m-monthly.csv"</span>
)</code></pre>

      </section><section class="slide" id="slide-15-5">
        <h2 id="csv-importieren">CSV importieren</h2>
<p>Mögliche Schlüsselwortargumente für <code>read_csv</code>:</p>
<ul>
<li><code>index_col</code>: identifiziert eine Spalte, die als Index verwendet werden soll</li>
<li><code>header</code>: übergeben des Werts <code>None</code> zeigt an, dass es keine Header-Zeile gibt</li>
<li><code>names</code>: Spaltennamen zur Verwendung im neuen <code>DataFrame</code></li>
<li><code>sep</code>: Angeben anderer Trennzeichen als ein Komma</li>
<li><code>usecols</code>: um nur bestimmte Spalten zu importieren</li>
<li><code>parse_dates</code>: erwartet eine Liste von Spaltennamen</li>
<li>...</li>
</ul>
<p>Siehe auch: <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html</a></p>

      </section><section class="slide" id="slide-15-6">
        <h2 id="csv-importieren">CSV importieren</h2>
<p>Fortgeschrittenes Euribor-Beispiel:</p>
<ul>
<li>Parsen des Datums</li>
<li>Datum als Index verwenden</li>
<li>Nur die Spalten <em>date</em> und <em>rate</em> importieren</li>
</ul>
<pre><code class="language-py">euribor = pd.read_csv(
    <span class="hljs-string">"https://datahub.io/core/euribor/r/euribor-12m-monthly.csv"</span>,
    parse_dates=[<span class="hljs-string">"date"</span>],
    index_col=<span class="hljs-string">"date"</span>,
    usecols=[<span class="hljs-string">"date"</span>, <span class="hljs-string">"rate"</span>]
)</code></pre>

      </section><section class="slide" id="slide-15-7">
        <h2 id="csv-importieren">CSV importieren</h2>
<p>Aufgabe: Importiere die folgenden Datenquellen und achte dabei auf passendes Format:</p>
<ul>
<li>Monatliche Preise des US-Aktienindex <em>S&amp;P 500</em>: <a href="https://datahub.io/core/s-and-p-500/r/data.csv">https://datahub.io/core/s-and-p-500/r/data.csv</a></li>
<li>Wechselkurse: <a href="https://datahub.io/core/us-euro-foreign-exchange-rate/r/monthly.csv">https://datahub.io/core/us-euro-foreign-exchange-rate/r/monthly.csv</a></li>
<li>Iris Dataset (Statistiken zu Blütengrößen von Iris-Blumen): <a href="http://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data">http://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data</a> (recherchiere passende Spaltennamen im Internet)</li>
</ul>

      </section><section class="slide" id="slide-15-8">
        <h2 id="csv-importieren">CSV importieren</h2>
<p>mögliche Lösungen:</p>
<pre><code class="language-py">iris = pd.read_csv(
    <span class="hljs-string">"http://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"</span>,
    header=<span class="hljs-keyword">None</span>,
    names=[<span class="hljs-string">"sepal_length"</span>, <span class="hljs-string">"sepal_width"</span>, <span class="hljs-string">"petal_length"</span>,
           <span class="hljs-string">"petal_width"</span>, <span class="hljs-string">"name"</span>])
sp500 = pd.read_csv(
    <span class="hljs-string">"https://datahub.io/core/s-and-p-500/r/data.csv"</span>,
    index_col=<span class="hljs-string">"Date"</span>,
    parse_dates=[<span class="hljs-string">"Date"</span>])
exchange_rates = pd.read_csv(
    <span class="hljs-string">"https://datahub.io/core/us-euro-foreign-exchange-rate/r/monthly.csv"</span>,
    parse_dates=[<span class="hljs-string">"Date"</span>])</code></pre>

      </section><section class="slide" id="slide-15-9">
        <h2 id="daten-importieren-und-exportieren">Daten importieren und exportieren</h2>
<p>Excel:</p>
<pre><code class="language-py">euribor.to_excel(<span class="hljs-string">'euribor.xlsx'</span>)
euribor = pd.read_excel(<span class="hljs-string">'euribor.xlsx'</span>, index_col=<span class="hljs-number">0</span>)</code></pre>
<p>HDF5 (<em>pytables</em> muss installiert sein):</p>
<pre><code class="language-py">euribor.to_hdf(<span class="hljs-string">"data.hdf5"</span>, <span class="hljs-string">"euribor"</span>)
euribor = read_hdf(<span class="hljs-string">"data.hdf5"</span>, <span class="hljs-string">"euribor"</span>)</code></pre>

      </section></section><section class="section" id="section-16"><section class="slide" id="slide-16-1">
        <h1 id="pandas-daten-auslesen">Pandas: Daten auslesen</h1>

      </section><section class="slide" id="slide-16-2">
        <h2 id="daten-auslesen-nach-zeilen--und-spaltennummern">Daten auslesen (nach Zeilen- und Spaltennummern)</h2>
<ul>
<li><code>df.iloc[5]</code>: Zeile 5 (gibt <code>Series</code>-Objekt zurück)</li>
<li><code>df.iloc[:5]</code>: erste 5 Zeilen (gibt <code>DataFrame</code>-Objekt zurück)</li>
<li><code>df.iloc[10:20]</code>: Zeilen 10-19</li>
<li><code>df.iloc[5, 1]</code>: Zeile 5, Spalte 1</li>
<li><code>df.iloc[5, [0, 2]]</code>: Zeile 5, Spalten 0 und 2</li>
</ul>

      </section><section class="slide" id="slide-16-3">
        <h2 id="daten-auslesen-nach-zeilen--und-spaltennamen">Daten auslesen (nach Zeilen- und Spaltennamen)</h2>
<ul>
<li><code>df.index</code>: Zeilennamen</li>
<li><code>df.columns</code>: Spaltennamen</li>
</ul>
<!-- -->

<ul>
<li><code>df.loc[&quot;2009-01-02&quot;]</code>: Zeile mit bestimmtem Indexwert</li>
<li><code>df.loc[&quot;2009-01-01&quot; : &quot;2009-01-31&quot;]</code>: Zeile in bestimmtem Bereich (beide Grenzen inklusive)</li>
<li><code>df.loc[:, &quot;rate&quot;]</code>: Spalte <code>&quot;rate&quot;</code></li>
<li><code>df[&quot;rate&quot;]</code>: Spalte <code>&quot;rate&quot;</code> (Kurzschreibweise)</li>
<li><code>df.rate</code>: Spalte <code>&quot;rate&quot;</code> (kürzere Version - klappt nicht mit Sonderzeichen)</li>
<li><code>df.loc[:, [&quot;rate&quot;, &quot;maturity_level&quot;]]</code>: zwei Spalten</li>
<li><code>df.loc[&quot;2009-01-02&quot;, &quot;rate&quot;]</code>: Bestimmte Zeile und Spalte</li>
</ul>

      </section><section class="slide" id="slide-16-4">
        <h2 id="zeilen-sortieren">Zeilen sortieren</h2>
<ul>
<li><code>df.sort_values(by=&quot;rate&quot;)</code></li>
<li><code>df.loc[&quot;2009-01-02&quot; : &quot;2009-12-31&quot;].sort_values(by=&quot;rate&quot;)</code></li>
<li><code>df.sort_index(ascending=False)</code></li>
</ul>

      </section><section class="slide" id="slide-16-5">
        <h2 id="zufällig-daten-auswählen">Zufällig Daten auswählen</h2>
<ul>
<li><code>df.sample()</code> - ein zufälliger Eintrag)</li>
<li><code>df.sample(5)</code> - fünf Einträge</li>
<li><code>df.sample(frac=0.1)</code> - 10% aller Einträge</li>
</ul>

      </section><section class="slide" id="slide-16-6">
        <h2 id="einträge-filtern">Einträge filtern</h2>
<p>Analog zur Funktionsweise von <em>NumPy</em>: alle Werte, die das Kriterium nicht erfüllen werden zu <em>NaN</em>.</p>
<pre><code class="language-py">iris[iris &gt; <span class="hljs-number">0</span>]</code></pre>

      </section><section class="slide" id="slide-16-7">
        <h2 id="zeilen-filtern">Zeilen filtern</h2>
<p>Zeilenweise filtern (ein zeilenweise gefilterter <em>DataFrame</em> wird zurückgegeben):</p>
<ul>
<li><code>df[df.rate &lt; 0]</code></li>
<li><code>df[df.length &lt; 0] = np.nan</code></li>
<li><code>df[df.name == &quot;Iris-setosa&quot;]</code></li>
<li><code>df[df.name.isin([&quot;Iris-setosa&quot;, &quot;Iris-virginica&quot;])])]</code></li>
</ul>

      </section><section class="slide" id="slide-16-8">
        <h2 id="zeilen-suchen">Zeilen suchen</h2>
<p>SQL Vorlage:</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> df
<span class="hljs-keyword">WHERE</span> a &lt; b <span class="hljs-keyword">AND</span> b &lt; c</code></pre>
<p>Pandas:</p>
<pre><code class="language-py">df[(df.a &lt; df.b) &amp; (df.b &lt; df.c)]</code></pre>
<p>oder</p>
<pre><code class="language-py">df.query(<span class="hljs-string">"a &lt; b &lt; c"</span>)</code></pre>

      </section><section class="slide" id="slide-16-9">
        <h2 id="aufgaben-euribor">Aufgaben (Euribor)</h2>
<ul>
<li>erster Eintrag</li>
<li>letzter Eintrag</li>
<li>letzte 10 Einträge</li>
<li>Eintrag vom 2.1.2009</li>
<li>Einträge aus dem Jahr 2009</li>
</ul>

      </section><section class="slide" id="slide-16-10">
        <h2 id="lösungen-euribor">Lösungen (Euribor)</h2>
<ul>
<li>erster Eintrag: <code>euribor.iloc[0]</code></li>
<li>letzter Eintrag: <code>euribor.iloc[-1]</code></li>
<li>letzte 10 Einträge: <code>euribor.iloc[-10:]</code></li>
<li>Eintrag vom 2.1.2009: <code>euribor.loc[&quot;2009-01-02&quot;]</code></li>
<li>Einträge vom 1.1.2009 bis 31.12.2009: <code>euribor.loc[&quot;2009-01-01&quot;: &quot;2009-12-31&quot;]</code></li>
</ul>

      </section><section class="slide" id="slide-16-11">
        <h2 id="aufgaben-iris">Aufgaben (Iris)</h2>
<ul>
<li>Maximale <em>petal length</em> von <em>iris setosa</em> (ohne <code>.max</code>)</li>
</ul>

      </section></section><section class="section" id="section-17"><section class="slide" id="slide-17-1">
        <h1 id="statistische-grundwerte">Statistische Grundwerte</h1>

      </section><section class="slide" id="slide-17-2">
        <h2 id="statistische-grundwerte">Statistische Grundwerte</h2>
<pre><code class="language-py">df.describe()</code></pre>

      </section><section class="slide" id="slide-17-3">
        <h2 id="statistische-grundwerte">Statistische Grundwerte</h2>
<pre><code class="language-py">countries.area.describe()</code></pre>
<pre><code class="language-txt">count     3.000000
mean     12.133333
std       4.215843
min       9.600000
25%       9.700000
50%       9.800000
75%      13.400000
max      17.000000
dtype: float64</code></pre>
<p>(Siehe nächste Folie für Erklärungen)</p>

      </section><section class="slide" id="slide-17-4">
        <h2 id="statistik-einer-series">Statistik einer Series</h2>
<pre><code class="language-py">countries.area.describe()</code></pre>
<p>berechnet die folgenden Daten:</p>
<ul>
<li><code>area.count()</code></li>
<li><code>area.mean()</code></li>
<li><code>area.std()</code></li>
<li><code>area.quantile(0)</code> / <code>area.min()</code></li>
<li><code>area.quantile(0.25)</code></li>
<li><code>area.quantile(0.5)</code> / <code>area.median()</code></li>
<li><code>area.quantile(0.75)</code></li>
<li><code>area.quantile(1)</code> / <code>ara.max()</code></li>
</ul>

      </section><section class="slide" id="slide-17-5">
        <h2 id="statistische-werte">Statistische Werte</h2>
<ul>
<li><em>std</em>: <em>Standardabweichung (Standard deviation)</em></li>
<li><em>median</em>: Hälfte der Werte liegt darüber, Hälfte liegt darunter</li>
<li><em>min</em>: alle Werte sind größer als das Minimum</li>
<li><em>25%-Quantil</em>: 25% aller Werte sind kleiner</li>
</ul>

      </section></section><section class="section" id="section-18"><section class="slide" id="slide-18-1">
        <h1 id="beispiel">Beispiel</h1>

      </section><section class="slide" id="slide-18-2">
        <h2 id="wechselkurse">Wechselkurse</h2>
<p><a href="https://datahub.io/core/exchange-rates/r/daily.csv">https://datahub.io/core/exchange-rates/r/daily.csv</a></p>
<p>Tägliche Wechselkurse zwischen USD und anderen Währungen</p>
<p>Wir lesen die Daten ein und wandeln sie so um, dass sie eine Zuordnung von Kalenderdaten zu täglichen EUR-USD Kursen darstellen</p>

      </section><section class="slide" id="slide-18-3">
        <h2 id="wechselkurse">Wechselkurse</h2>
<p>Lösung:</p>
<pre><code class="language-py">er = pd.read_csv(
    <span class="hljs-string">"https://datahub.io/core/exchange-rates/r/daily.csv"</span>,
    parse_dates=[<span class="hljs-number">1</span>])

<span class="hljs-comment"># only select euro</span>
er_eur_full = er.loc[er.Country==<span class="hljs-string">"Euro"</span>]

<span class="hljs-comment"># now we can set the date as the index</span>
er_eur_dateindex = er_eur_full.set_index(<span class="hljs-string">'Date'</span>)

<span class="hljs-comment"># we can drop the country information</span>
er_eur = er_eur_dateindex.loc[:, <span class="hljs-string">'Value'</span>]</code></pre>

      </section></section><section class="section" id="section-19"><section class="slide" id="slide-19-1">
        <h1 id="pandas-daten-manipulieren">Pandas: Daten manipulieren</h1>

      </section><section class="slide" id="slide-19-2">
        <h2 id="spalten-umbenennen">Spalten umbenennen</h2>
<pre><code class="language-py">df.columns = [<span class="hljs-string">"name1"</span>, <span class="hljs-string">"name2"</span>]</code></pre>

      </section><section class="slide" id="slide-19-3">
        <h2 id="daten-entfernen">Daten entfernen</h2>
<p>Zeilen entfernen:</p>
<pre><code class="language-py">df2 = df1.drop([<span class="hljs-string">"CN"</span>, <span class="hljs-string">"US"</span>])</code></pre>
<p>Spalten entfernen:</p>
<pre><code class="language-py">df2 = df1.drop(columns=[<span class="hljs-string">"pop"</span>])</code></pre>

      </section><section class="slide" id="slide-19-4">
        <h2 id="abgeleitete-werte-berechnen">Abgeleitete Werte berechnen</h2>
<pre><code class="language-py">iris[<span class="hljs-string">"sepal_ratio"</span>] = iris[<span class="hljs-string">"sepal_length"</span>] / iris[<span class="hljs-string">"sepal_width"</span>]

iris[<span class="hljs-string">"sepal_ratio"</span>].mean()
iris[<span class="hljs-string">"sepal_ratio"</span>].std()

iris_setosa = iris.loc[
    iris[<span class="hljs-string">"name"</span>] == <span class="hljs-string">"Iris-setosa"</span>
]

iris_setosa[<span class="hljs-string">"sepal_ratio"</span>].mean()
iris_setosa[<span class="hljs-string">"sepal_ratio"</span>].std()</code></pre>

      </section><section class="slide" id="slide-19-5">
        <h2 id="abgeleitete-werte-berechnen-mittels-eigenen-funktionen">Abgeleitete Werte berechnen mittels eigenen Funktionen</h2>
<pre><code class="language-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classifier</span><span class="hljs-params">(value)</span>:</span>
    <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">2</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">elif</span> value &lt; <span class="hljs-number">10</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>

df[<span class="hljs-string">"class"</span>] = df[<span class="hljs-string">"value"</span>].apply(classifier)</code></pre>

      </section><section class="slide" id="slide-19-6">
        <h2 id="einzelne-daten-setzen">Einzelne Daten setzen</h2>
<pre><code class="language-py">iris.iloc[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] = <span class="hljs-number">6</span>

iris.loc[:, <span class="hljs-string">"sepal_ratio"</span>] = float(<span class="hljs-string">'nan'</span>)</code></pre>

      </section></section><section class="section" id="section-20"><section class="slide" id="slide-20-1">
        <h1 id="fehlende-daten">Fehlende Daten</h1>

      </section><section class="slide" id="slide-20-2">
        <h2 id="fehlende-daten">Fehlende Daten</h2>
<p>In den Wechselkursdaten fehlen manche Einträge:</p>
<ul>
<li>manche Tage sind nicht eingetragen (Wochenenden)</li>
<li>manche Tage sind als <code>NaN</code>s eingetragen</li>
</ul>

      </section><section class="slide" id="slide-20-3">
        <h2 id="fehlende-daten">Fehlende Daten</h2>
<p>Entfernen aller Zeilen mit fehlenden Daten:</p>
<pre><code class="language-py">er = er.dropna()</code></pre>
<p>Ersetzen aller fehlender Daten mit Nullen:</p>
<pre><code class="language-py">er = er.fillna(<span class="hljs-number">0</span>)</code></pre>
<p>Ersetzen aller fehlernder Daten mit Werten der Reihe zuvor:</p>
<pre><code class="language-py">er = er.fillna(method=<span class="hljs-string">"backfill"</span>)</code></pre>

      </section><section class="slide" id="slide-20-4">
        <h2 id="fehlende-daten">Fehlende Daten</h2>
<p>Daten interpolieren:</p>
<pre><code class="language-py">er = er.intepolate()
er = er.interpolate(method=<span class="hljs-string">"spline"</span>)</code></pre>
<p>Beispiel:</p>
<pre><code class="language-py">url = <span class="hljs-string">'https://datahub.io/core/interest-rates-gb/r/data.csv'</span>

ir_uk = pd.read_csv(url, index_col=<span class="hljs-string">"date"</span>,
                    parse_dates=<span class="hljs-keyword">True</span>)

ir_uk_weekly = ir_uk.resample(<span class="hljs-string">'7d'</span>).interpolate()</code></pre>

      </section><section class="slide" id="slide-20-5">
        <h2 id="übung">Übung</h2>
<p>Nutze die Daten aus <em>sp500</em> und <em>euribor</em>, um die Entwicklungen der europäischen und amerikanischen Zinssätze einander gegenüberzustellen.</p>

      </section></section><section class="section" id="section-21"><section class="slide" id="slide-21-1">
        <h1 id="kontingenztabelle">Kontingenztabelle</h1>

      </section><section class="slide" id="slide-21-2">
        <h2 id="kontingenztabelle">Kontingenztabelle</h2>
<p>Eine <em>Kontingenztabelle</em> oder <em>Kreuztabelle</em> gibt Anzahlen über mehrere Merkmale hinweg an.</p>
<p>Sie kann mittels <code>pd.crosstab</code> erstellt werden.</p>

      </section><section class="slide" id="slide-21-3">
        <h2 id="kontingenztabelle">Kontingenztabelle</h2>
<p>Beispiel:</p>
<pre><code class="language-py"><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
titanic = sns.load_dataset(<span class="hljs-string">"titanic"</span>)
pd.crosstab(titanic.survived, titanic.sex)</code></pre>
<p>Ausgabe:</p>
<pre><code>sex       female  male
survived              
0             81   468
1            233   109</code></pre>
      </section></section><section class="section" id="section-22"><section class="slide" id="slide-22-1">
        <h1 id="gruppierung">Gruppierung</h1>

      </section><section class="slide" id="slide-22-2">
        <h2 id="gruppierung">Gruppierung</h2>
<p>Einteilung der Daten in Gruppen / Kategorien und berechnen von Werten auf deren Basis</p>
<p>Beispiel: Durchschnittswerte der Iris-Daten basierend auf dem Namen der Art</p>
<pre><code class="language-py">iris.groupby(iris.name).mean()</code></pre>
<pre><code>                 sepal_length  sepal_width  petal_length  petal_width
name                                                                 
Iris-setosa             5.006        3.418         1.464        0.244
Iris-versicolor         5.936        2.770         4.260        1.326
Iris-virginica          6.588        2.974         5.552        2.026</code></pre>
      </section><section class="slide" id="slide-22-3">
        <h2 id="gruppierung">Gruppierung</h2>
<p>Aufgabe: Durchschnittliche USD-Wechselkurse für jede Währung in den 90ern</p>

      </section></section><section class="section" id="section-23"><section class="slide" id="slide-23-1">
        <h1 id="multi-index">Multi-Index</h1>

      </section><section class="slide" id="slide-23-2">
        <h2 id="multi-index">Multi-Index</h2>
<p>Index-Spalte: Spalte, anhand deren Einträge die Zeilen eindeutig identifiziert werden können</p>
<p>Multi-Index: Kombination aus mehreren Spalten zur eindeutigen Identifikation</p>

      </section><section class="slide" id="slide-23-3">
        <h2 id="multi-index">Multi-Index</h2>
<p>Beispiel: Exchange rates</p>
<table>
<thead>
<tr>
<th>Date</th>
<th>Country</th>
<th>Exchange rate</th>
</tr>
</thead>
<tbody><tr>
<td>1971-01-01</td>
<td>Australia</td>
<td>0.894</td>
</tr>
<tr>
<td>1971-02-01</td>
<td>Australia</td>
<td>0.890</td>
</tr>
<tr>
<td>1971-03-01</td>
<td>Australia</td>
<td>0.890</td>
</tr>
</tbody></table>
<p>Eine Zeile kann durch Kombination von <em>date</em> und <em>country</em> eindeutig identifiziert werden.</p>

      </section><section class="slide" id="slide-23-4">
        <h2 id="multi-index">Multi-Index</h2>
<p>Importieren mit Multi-Index:</p>
<pre><code class="language-py">exchange_rates = pd.read_csv(
    <span class="hljs-string">"https://datahub.io/core/us-euro-foreign-exchange-rate/r/monthly.csv"</span>,
    index_col=[<span class="hljs-string">"Country"</span>, <span class="hljs-string">"Date"</span>]
    parse_dates=[<span class="hljs-string">"Date"</span>])</code></pre>

      </section></section><section class="section" id="section-24"><section class="slide" id="slide-24-1">
        <h1 id="numpy-fortgeschritten">NumPy Fortgeschritten</h1>

      </section><section class="slide" id="slide-24-2">
        <h2 id="form-von-arrays-ändern">Form von Arrays ändern</h2>
<pre><code class="language-py">array_1d = array_3d.ravel()
array_1d = array_3d.reshape(<span class="hljs-number">8</span>)
array_2d = array_3d.reshape(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)
array_2d = array_3d.reshape(<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>) <span class="hljs-comment"># automatic second dimension</span>
array_2d_transposed = array_2d.T</code></pre>

      </section><section class="slide" id="slide-24-3">
        <h2 id="dimensionalität-erhöhen">Dimensionalität erhöhen</h2>
<p>Hinzufügen einer extra Dimension der Länge 1 via <code>newaxis</code> - Verwandeln eines 2 x 2 Arrays in ein 2 x 2 x 1 Array:</p>
<pre><code class="language-py">array_2d = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])
array_3d = array_2d[:, :, np.newaxis]
<span class="hljs-comment"># [[[1], [2]], [[3], [4]]]</span></code></pre>

      </section><section class="slide" id="slide-24-4">
        <h2 id="slices-als-views">Slices als Views</h2>
<p>In Python können wir eine flache Kopie einer Liste erstellen, indem wir sie slicen - dies ist in NumPy nicht so (um die Effizienz zu steigern):</p>
<pre><code class="language-py">list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
list_copy = list[:]
list_copy[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span> <span class="hljs-comment"># does NOT change list</span>

array = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
array_view = array[:]
array_view[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span> <span class="hljs-comment"># DOES change array</span></code></pre>

      </section><section class="slide" id="slide-24-5">
        <h2 id="arrays-kopieren">Arrays kopieren</h2>
<p>Arrays können via <code>array.copy()</code> kopiert werden</p>

      </section><section class="slide" id="slide-24-6">
        <h2 id="arrays-aneinanderfügen">Arrays aneinanderfügen</h2>
<p>nebeineinander anfügen:</p>
<pre><code class="language-py">np.concatenate([a1d, a1d])
np.concatenate([a2d, a2d])</code></pre>
<p>untereinander anfügen:</p>
<pre><code class="language-py">np.concatenate([a2d, a2d], axis=<span class="hljs-number">1</span>)</code></pre>

      </section><section class="slide" id="slide-24-7">
        <h2 id="matrix-multiplikation">Matrix-Multiplikation</h2>
<p>Matrix-Multiplikation kann durch den binären Operator <code>@</code> durchgeführt werden</p>
<pre><code class="language-py">a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>])

M = np.array([[<span class="hljs-number">0.707</span>, <span class="hljs-number">0.707</span>],
              [<span class="hljs-number">-0.707</span>, <span class="hljs-number">0.707</span>]])

print(a @ M)
<span class="hljs-comment"># array([0.   , 1.414])</span></code></pre>

      </section><section class="slide" id="slide-24-8">
        <h2 id="matrix-multiplikation">Matrix-Multiplikation</h2>
<p>Rotation verschiedener Punkte um 45° gegen den Uhrzeigersinn:</p>
<pre><code class="language-py">points = np.array([[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]])

M = np.array([[<span class="hljs-number">0.707</span>, <span class="hljs-number">0.707</span>],
              [<span class="hljs-number">-0.707</span>, <span class="hljs-number">0.707</span>]])

print(points @ M)</code></pre>

      </section><section class="slide" id="slide-24-9">
        <h2 id="matrix-multiplikation">Matrix-Multiplikation</h2>
<p>Preise verschiedener Produkte:</p>
<pre><code class="language-py">prices = np.array([<span class="hljs-number">3.99</span>, <span class="hljs-number">12.99</span>, <span class="hljs-number">5.90</span>, <span class="hljs-number">15</span>])</code></pre>
<p>Bestände in verschiedenen Lagern:</p>
<pre><code class="language-py">quantities = np.array([[<span class="hljs-number">0</span>, <span class="hljs-number">80</span>, <span class="hljs-number">80</span>, <span class="hljs-number">100</span>],
                       [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
                       [<span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>]])</code></pre>
<p>Gesucht: Warenwert pro Lager</p>

      </section></section><section class="section" id="section-25"><section class="slide" id="slide-25-1">
        <h1 id="machine-learning">Machine learning</h1>

      </section><section class="slide" id="slide-25-2">
        <h2 id="kategorien-von-methoden">Kategorien von Methoden</h2>
<ul>
<li>Supervised learning (Überwachtes Lernen)</li>
<li>Unsupervised learning</li>
<li>Reinforcement learning</li>
</ul>

      </section><section class="slide" id="slide-25-3">
        <h2 id="beispiele-für-aufgaben">Beispiele für Aufgaben</h2>
<ul>
<li>Regression</li>
<li>Klassifizierung</li>
<li>Clustering</li>
<li>Dimensionsreduktion</li>
</ul>

      </section><section class="slide" id="slide-25-4">
        <h2 id="beispiele-für-aufgaben">Beispiele für Aufgaben</h2>
<h3 id="regression">Regression</h3>
<p>Zuweisung von numerischen Werten zu numerischen Eingabedaten</p>
<p>Beispiele:</p>
<ul>
<li>Schätzung der Entfernung einer Galaxie basierend auf der Rotverschiebung</li>
<li>Schätzung der Kursentwicklung einer Aktie</li>
</ul>

      </section><section class="slide" id="slide-25-5">
        <h2 id="beispiele-für-aufgaben">Beispiele für Aufgaben</h2>
<h3 id="klassifikation">Klassifikation</h3>
<p>Zuweisung von Klassen zu numerischen Eingabedaten</p>
<p>Beispiele:</p>
<ul>
<li>Spam-Filterung basierend auf einer Anzahl an Wörtern / Phrasen (2x &quot;nigerian prince&quot;, 1x &quot;viagra&quot;)</li>
<li>Erkennen von Objekten / Personen / Zeichen auf Bildern</li>
</ul>

      </section><section class="slide" id="slide-25-6">
        <h2 id="beispiele-für-aufgaben">Beispiele für Aufgaben</h2>
<h3 id="clustering">Clustering</h3>
<p>Erkennen von Gruppierungen / Clustern bei numerischen Eingabedaten</p>
<p>Beispiele:</p>
<ul>
<li>Erkennen wiederkehrender Elemente in Bildern</li>
</ul>

      </section></section><section class="section" id="section-26"><section class="slide" id="slide-26-1">
        <h1 id="regression---grundlagen">Regression - Grundlagen</h1>

      </section><section class="slide" id="slide-26-2">
        <h2 id="lineare-regression">Lineare Regression</h2>

      </section><section class="slide" id="slide-26-3">
        <h2 id="lineare-regression">Lineare Regression</h2>
<p>Beispiel: Wir betrachten verschiedene Einkäufe bei verschiedenen Supermärkten:</p>
<ul>
<li>1 l Milch, 1 kg Brot: 4.58€</li>
<li>2 l Milch, 3 kg Brot: 13.50€</li>
<li>3 l Milch, 2 kg Brot: 11.98€</li>
<li>(0 l Milch, 0 kg Brot: 0€)</li>
</ul>
<p>Was wäre eine passende Schätzung für den Preis von 1 Liter Milch / 1 kg Brot? Wenn wir bei einem Supermarkt 2 Liter Milch und 2 kg Brot kaufen, welcher Preis wäre in etwa zu erwarten?</p>
<p>Diese Aufgabe kann mit Hilfe von linearer Regression beantwortet werden.</p>

      </section><section class="slide" id="slide-26-4">
        <h2 id="lineare-regression">Lineare Regression</h2>
<p>Beispiel:</p>
<pre><code class="language-py"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression

X = [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]
y = [<span class="hljs-number">4.58</span>, <span class="hljs-number">14.50</span>, <span class="hljs-number">11.98</span>, <span class="hljs-number">0.0</span>]

model = LinearRegression()
model.fit(X, y)

yfit = model.predict([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>]])
print(yfit)</code></pre>

      </section><section class="slide" id="slide-26-5">
        <h2 id="lineare-regression---beispiel">Lineare Regression - Beispiel</h2>
<p>Iris-Datensatz: Abschätzen der <em>sepal width</em> basierend auf der <em>sepal length</em></p>
<pre><code class="language-py"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets
iris = datasets.load_iris()</code></pre>

      </section><section class="slide" id="slide-26-6">
        <h2 id="lineare-regression---erlernte-koeffizienten">Lineare Regression - erlernte Koeffizienten</h2>
<ul>
<li><code>model.coef_</code></li>
<li><code>model.intercept_</code></li>
</ul>

      </section></section><section class="section" id="section-27"><section class="slide" id="slide-27-1">
        <h1 id="klassifizierung---grundlagen">Klassifizierung - Grundlagen</h1>

      </section><section class="slide" id="slide-27-2">
        <h2 id="klassifizierung">Klassifizierung</h2>
<p>Aufgabe: Klassifizierung von Iris-Pflanzen basierend auf ihren Maßen</p>
<p>Gegeben ist eine Reihe von Daten mit bekannten Maßen und bekannten Spezies. Baiserend darauf: Trainieren eines Algorithmus, um später die Spezies anderer Pflanzen zu bestimmen.</p>

      </section><section class="slide" id="slide-27-3">
        <h2 id="klassifizierung">Klassifizierung</h2>
<p>In diesem Fall verwenden wir einen <em>K-nearest-neighbors-Klassifikator</em> als Algorithmus, andere Algorithmen wären genauso denkbar.</p>

      </section><section class="slide" id="slide-27-4">
        <h2 id="klassifizierung">Klassifizierung</h2>
<p>Trainieren des Algorithmus:</p>
<pre><code class="language-py"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier
<span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets

iris = datasets.load_iris()

X = iris.data
y = iris.target

model = KNeighborsClassifier()
model.fit(X, y)</code></pre>

      </section><section class="slide" id="slide-27-5">
        <h2 id="klassifizierung">Klassifizierung</h2>
<p>Durchführen der Klassifizierung</p>
<pre><code class="language-py">test_data = [
    [<span class="hljs-number">5.3</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">1.9</span>, <span class="hljs-number">0.6</span>],
    [<span class="hljs-number">6.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.7</span>, <span class="hljs-number">1.5</span>],
    [<span class="hljs-number">6.5</span>, <span class="hljs-number">3.1</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">1.7</span>]
]

y_pred = model.predict(test_data)
print(y_pred)</code></pre>

      </section><section class="slide" id="slide-27-6">
        <h2 id="klassifizierung">Klassifizierung</h2>
<p>Weitere Aufgaben:</p>
<p>Wir verwenden andere Klassifikatoren, wie etwa:</p>
<ul>
<li><code>SVC</code></li>
<li><code>DecisionTreeClassifier</code></li>
<li><code>GaussianNB</code></li>
</ul>

      </section><section class="slide" id="slide-27-7">
        <h2 id="klassifizierung">Klassifizierung</h2>
<p>Bei vielen Klassifizierungsalgorithmen können auch Wahrscheinlichkeiten für die einzelnen Klassen angezeigt werden:</p>
<pre><code class="language-py">model.predict_proba(test_data)</code></pre>
<pre><code class="language-py">array([[<span class="hljs-number">1.</span> , <span class="hljs-number">0.</span> , <span class="hljs-number">0.</span> ],
       [<span class="hljs-number">0.</span> , <span class="hljs-number">0.8</span>, <span class="hljs-number">0.2</span>],
       [<span class="hljs-number">0.</span> , <span class="hljs-number">0.6</span>, <span class="hljs-number">0.4</span>]])</code></pre>
<p>Der erste Eintrag gehört sicher zur ersten Klasse, der letzte Eintrag gehört mit 60-prozentiger Sicherheit zur zweiten Klasse.</p>

      </section></section><section class="section" id="section-28"><section class="slide" id="slide-28-1">
        <h1 id="regression-und-klassifikation-verfahren">Regression und Klassifikation: Verfahren</h1>

      </section><section class="slide" id="slide-28-2">
        <h2 id="regression-und-klassifikation-verfahren">Regression und Klassifikation: Verfahren</h2>
<ul>
<li>Instanziierung einer Algorithmenklasse, z.B. <code>LinerRegression</code>, <code>KNeighborsClassifier</code>, <code>DecisionTreeClassifier</code>, ...</li>
<li>Erstellen einer Eingangsmatrix <code>X</code> und eines Zielvektors <code>y</code></li>
<li>&quot;Lernen&quot; mittels <code>model.fit(X, y)</code></li>
<li>Voraussagen weiterer Ergebnisse mittels <code>model.predict(...)</code></li>
</ul>

      </section></section><section class="section" id="section-29"><section class="slide" id="slide-29-1">
        <h1 id="validierung">Validierung</h1>

      </section><section class="slide" id="slide-29-2">
        <h2 id="train-test-split">Train-Test Split</h2>
<p>Um zu validieren, ob ein Verfahren ein passendes Ergebnis liefert:</p>
<p>Die Daten (X, y) werden in Trainingsdaten und Testdaten unterteilt. Die Testdaten dienen zur Validierung.</p>

      </section><section class="slide" id="slide-29-3">
        <h2 id="train-test-split">Train-Test Split</h2>
<p>Frage: wie gut approximiert unsere lineare Regression die Iris Daten?</p>
<pre><code class="language-py"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split
<span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> metrics

X_train, X_test, y_train, y_test = train_test_split(X, y)

...

print(metrics.r2_score(y_prediction, y_test))</code></pre>
<p>Wir können einen Parameter <code>test_size</code> angeben, dessen Standardwert <code>0.25</code> ist (d.h. 25% der Daten werden zur Validierung verwendet)</p>

      </section><section class="slide" id="slide-29-4">
        <h2 id="validierungsmetriken">Validierungsmetriken</h2>
<p>Regression:</p>
<ul>
<li><code>metrics.mean_squared_error(y_true, y_pred)</code> (mittlere quadratische Abweichung)</li>
<li><code>metrics.r2_score(y_true, y_pred)</code> (R², Bestimmtheitsmaß)</li>
</ul>
<p>Klassifizierung:</p>
<ul>
<li><code>metrics.accuracy_score(y_true, y_pred)</code> (Anteil an richtig klassifizierten Einträgen)</li>
<li><code>metrics.confusion_matrix(y_true, y_pred)</code> (Anteil an richtig / falsch klassifizierten Einträgen für jede Klasse)</li>
<li><code>metrics.precision_recall_fscore_support(y_true, y_pred)</code> (Zusammenfassung wichtiger Metriken)</li>
</ul>
<p>Siehe auch <a href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.metrics">https://scikit-learn.org/stable/modules/classes.html#module-sklearn.metrics</a></p>

      </section><section class="slide" id="slide-29-5">
        <h2 id="validierungsmetriken-bestimmtheitsmaß">Validierungsmetriken: Bestimmtheitsmaß</h2>
<p>Das Bestimmtheitsmaß (R²) gibt an, wie nahe die Interpolation an den Testdaten liegt:</p>
<ul>
<li>R²=1 - perfekte Interpolation</li>
<li>R²=0 - Interpolation nicht besser als der einfache Durchschnitt</li>
<li>R²&lt;0 - schlechter als der einfache Durchschnitt </li>
</ul>

      </section><section class="slide" id="slide-29-6">
        <h2 id="validierung">Validierung</h2>
<p>Aufgaben:</p>
<ul>
<li>Validierung der Iris-Regression</li>
<li>Validierung der Iris-Klassifizierung</li>
</ul>

      </section><section class="slide" id="slide-29-7">
        <h2 id="kreuzvalidierung">Kreuzvalidierung</h2>
<p>Bei der Kreuzvalidierung (cross-validation) werden die Daten wiederholt in unterschiedliche Trainings- und Testdaten unterteilt, sodass jeder Eintrag einmal in den Testdaten vorkommt.</p>
<pre><code class="language-py"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> cross_validate

...

test_results = cross_validate(model, X, y, cv=<span class="hljs-number">5</span>, scoring=<span class="hljs-string">"r2"</span>)
test_scores = test_results[<span class="hljs-string">"test_score"</span>]
print(test_scores)
<span class="hljs-comment"># [ 0.61840428  0.72569954 -1.1742135   0.44294841  0.50589789]</span></code></pre>

      </section></section><section class="section" id="section-30"><section class="slide" id="slide-30-1">
        <h1 id="daten-vorbereiten">Daten vorbereiten</h1>

      </section><section class="slide" id="slide-30-2">
        <h2 id="daten-vorbereiten">Daten vorbereiten</h2>
<p>üblicherweise:</p>
<ul>
<li><code>X</code>: zweidimensionales Array mit Eingangsdaten</li>
<li><code>y</code>: eindimensionales Array mit Resultaten</li>
</ul>
<p>Die Arrays <code>X</code> und <code>y</code> sollten numerische Daten enthalten</p>

      </section><section class="slide" id="slide-30-3">
        <h2 id="daten-vorbereiten">Daten vorbereiten</h2>
<p>Aufgaben:</p>
<ul>
<li>Fehlende Daten ergänzen</li>
<li>Skalieren von Werten</li>
<li>Kategoriedaten in numerische Daten umwandeln</li>
<li>Textdaten in numerische Daten umwandeln</li>
</ul>

      </section><section class="slide" id="slide-30-4">
        <h2 id="daten-vorbereiten">Daten vorbereiten</h2>
<p>Klassen zum vorbereiten der Daten besitzen folgende Methoden:</p>
<ul>
<li><code>.fit</code>: erlernt anhand vorgegebener Eingangsdaten (<code>X1</code>) eine passende Umwandlung für das Modell</li>
<li><code>.transform</code>: wandelt gegebene Eingangsdaten (<code>X2</code>) anhand des gelernten in die neue Form um</li>
<li><code>.fit_transform</code>: beides in einem Schritt (für die gleichen Daten)</li>
</ul>

      </section><section class="slide" id="slide-30-5">
        <h2 id="fehlende-daten">Fehlende Daten</h2>
<p>Fehlende Daten werden häufig in der Form von <code>NaN</code>s auftreten.</p>
<p>Mögliche Behandlungen:</p>
<ul>
<li>Löschen aller Zeilen, die an irgendeiner Stelle undefinierte Werte enthalten</li>
<li>Interpolieren der fehlenden Werte durch andere Daten</li>
</ul>

      </section><section class="slide" id="slide-30-6">
        <h2 id="fehlende-daten-interpolation">Fehlende Daten: Interpolation</h2>
<pre><code class="language-py"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> sklearn.impute <span class="hljs-keyword">import</span> SimpleImputer
X = np.array([[ np.nan, <span class="hljs-number">0</span>,   <span class="hljs-number">3</span>  ],
              [ <span class="hljs-number">3</span>,   <span class="hljs-number">7</span>,   <span class="hljs-number">9</span>  ],
              [ <span class="hljs-number">3</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">2</span>  ],
              [ <span class="hljs-number">4</span>,   np.nan, <span class="hljs-number">6</span>  ],
              [ <span class="hljs-number">8</span>,   <span class="hljs-number">8</span>,   <span class="hljs-number">1</span>  ]])

imputer = SimpleImputer(strategy=<span class="hljs-string">"mean"</span>)
imputer.fit(X)

imputer.transform(X)
imputer.transform(np.array([[np.nan, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]]))</code></pre>

      </section><section class="slide" id="slide-30-7">
        <h2 id="skalieren-von-werten">Skalieren von Werten</h2>
<p>Welcher dieser beiden Sterne ist der Sonne am ähnlichsten?</p>
<pre><code class="language-py"><span class="hljs-comment"># data: radius (km), mass (kg), temparature (K)</span>
sun =    [<span class="hljs-number">7.0e7</span>, <span class="hljs-number">2.0e30</span>, <span class="hljs-number">5.8e3</span>]

star_a = [<span class="hljs-number">6.5e7</span>, <span class="hljs-number">3.0e30</span>, <span class="hljs-number">5.2e3</span>]
star_b = [<span class="hljs-number">7.0e8</span>, <span class="hljs-number">2.5e30</span>, <span class="hljs-number">8.1e3</span>]</code></pre>
<p>Machine Learning Algorithmen wie z.B. k-Nearest-Neighbor betrachten Absolutwerte. Hier würde vom Algorithmus im wesentlichen nur die Masse herangezogen worden, da alle anderen Werte im Vergleich verschwindend gering sind.</p>

      </section><section class="slide" id="slide-30-8">
        <h2 id="skalieren-von-werten">Skalieren von Werten</h2>
<p>Lösung: Die Werte werden zentriert und skaliert, sodass ihr Mittelwert 0 und die Standardabweichung 1 ist</p>
<pre><code class="language-py"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> preprocessing
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
X_train = np.array([[ <span class="hljs-number">7.0e7</span>, <span class="hljs-number">2.0e30</span>, <span class="hljs-number">5.8e3</span>],
                    [ <span class="hljs-number">6.5e7</span>, <span class="hljs-number">3.0e30</span>, <span class="hljs-number">5.2e3</span>],
                    [ <span class="hljs-number">7.0e9</span>, <span class="hljs-number">2.5e30</span>, <span class="hljs-number">3.1e3</span>]])

scaler = preprocessing.StandardScaler()
scaler.fit(X_train)
X_train_scaled = scaler.transform(X_train)</code></pre>

      </section><section class="slide" id="slide-30-9">
        <h2 id="skalieren-von-werten">Skalieren von Werten</h2>
<p>Skalierte Werte:</p>
<pre><code class="language-py">array([[<span class="hljs-number">-0.70634165</span>, <span class="hljs-number">-1.22474487</span>,  <span class="hljs-number">0.95025527</span>],
       [<span class="hljs-number">-0.70787163</span>,  <span class="hljs-number">1.22474487</span>,  <span class="hljs-number">0.43193421</span>],
       [ <span class="hljs-number">1.41421329</span>,  <span class="hljs-number">0.</span>        , <span class="hljs-number">-1.38218948</span>]])</code></pre>

      </section><section class="slide" id="slide-30-10">
        <h2 id="skalieren-von-werten">Skalieren von Werten</h2>
<p>Aufgabe: Vergleich einer skalierten Version der Iris k-Nearest-Neighbor-Klassifizierung mit der nichtskalierten</p>

      </section><section class="slide" id="slide-30-11">
        <h2 id="kategorien-als-eingangsdaten">Kategorien als Eingangsdaten</h2>
<p>Manchmal sind <em>Kategorien</em> als Eingangsdaten angegeben - z.B. Land, Berufsgruppe, Messverfahren, ...</p>
<p>Diese können in numerische Daten umgewandelt werden, indem jeder Kategorie eine Spalte mit booleschen Einträgen (0 / 1) zugeordnet wird.</p>
<p>Dies geschieht z.B. mit <code>sklearn.preprocessing.LabelBinarizer</code>.</p>

      </section><section class="slide" id="slide-30-12">
        <h2 id="kategorien-als-eingangsdaten">Kategorien als Eingangsdaten</h2>
<pre><code class="language-py"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> LabelBinarizer
data = [<span class="hljs-string">'cold'</span>, <span class="hljs-string">'cold'</span>, <span class="hljs-string">'warm'</span>, <span class="hljs-string">'cold'</span>, <span class="hljs-string">'hot'</span>, <span class="hljs-string">'hot'</span>]

lb = LabelBinarizer()
lb.fit(data)
X = lb.transform(data)
print(X)</code></pre>
<pre><code class="language-py">array([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
       [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
       [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
       [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
       [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],
       [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]])</code></pre>

      </section><section class="slide" id="slide-30-13">
        <h2 id="textdaten">Textdaten</h2>
<p>Beispiel für das Preprocessing von Textdaten: Zählen von Worten</p>
<pre><code class="language-py"><span class="hljs-keyword">from</span> sklearn.feature_extraction.text <span class="hljs-keyword">import</span> CountVectorizer

sample = [<span class="hljs-string">'problem of evil'</span>,
          <span class="hljs-string">'evil queen'</span>,
          <span class="hljs-string">'horizon problem'</span>]

vectorizer = CountVectorizer()
vectorizer.fit(sample)
print(vectorizer.vocabulary_)
X = vectorizer.transform(sample)
print(X)
print(X.todense())</code></pre>

      </section><section class="slide" id="slide-30-14">
        <h2 id="pipelines">Pipelines</h2>
<p>Pipelines können aus mehreren transformierenden Algorithmen und einem vorhersagenden Algorithmus zusammengesetzt werden:</p>
<pre><code class="language-py"><span class="hljs-keyword">from</span> sklearn.pipeline <span class="hljs-keyword">import</span> make_pipeline
<span class="hljs-keyword">from</span> sklearn.impute <span class="hljs-keyword">import</span> SimpleImputer
<span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler

model = make_pipeline(
    SimpleImputer(strategy=<span class="hljs-string">'mean'</span>),
    StandardScaler,
    LinearRegression()
)</code></pre>

      </section><section class="slide" id="slide-30-15">
        <h2 id="beispiel-preprocessing-von-textdaten-newsgroups">Beispiel: Preprocessing von Textdaten (Newsgroups)</h2>
<p><a href="https://jakevdp.github.io/PythonDataScienceHandbook/05.05-naive-bayes.html#Multinomial-Naive-Bayes">Multinomial Naive Bayes - Python Data Science Handbook</a></p>

      </section></section><section class="section" id="section-31"><section class="slide" id="slide-31-1">
        <h1 id="regression">Regression</h1>

      </section><section class="slide" id="slide-31-2">
        <h2 id="lineare-regression">Lineare Regression</h2>
<p>Bedeutet: Festlegen einer linearen Funktion, die die Datenpunkte bestmöglich approximiert (kleinste Quadratsumme)</p>

      </section><section class="slide" id="slide-31-3">
        <h2 id="lineare-regression---beispiele">Lineare Regression - Beispiele</h2>
<ul>
<li>Diabetes Vorhersage</li>
<li>(<a href="https://jakevdp.github.io/PythonDataScienceHandbook/05.06-linear-regression.html#Example:-Predicting-Bicycle-Traffic">Radverkehr</a>)</li>
</ul>

      </section></section><section class="section" id="section-32"><section class="slide" id="slide-32-1">
        <h1 id="polynomiale-regression">Polynomiale Regression</h1>

      </section><section class="slide" id="slide-32-2">
        <h2 id="polynomiale-regression">Polynomiale Regression</h2>
<p>Manche Daten passen nicht in das Schema eines linearen Zusammenhangs <code>y = a*x + b</code>.</p>
<p>Wir können z.B. versuchen, sie durch einen polynomialen Zusammenhang <code>y = a*x^2 + b*x + c</code> darzustellen.</p>

      </section><section class="slide" id="slide-32-3">
        <h2 id="polynomiale-regression">Polynomiale Regression</h2>
<p>In scikit-learn können wir eine polynomiale Regression durch einen <em>Preprocessor</em> namens <code>PolynomialFeatures</code> durchführen.</p>

      </section><section class="slide" id="slide-32-4">
        <h2 id="polynomiale-regression">Polynomiale Regression</h2>
<p>Als Beispieldaten verwenden wir den Datensatz <em>II</em> aus den sogenannten Anscombe Daten:</p>
<pre><code class="language-py"><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns

anscombe = sns.load_dataset(<span class="hljs-string">"anscombe"</span>)
anscombe_2 = anscombe[anscombe.dataset == <span class="hljs-string">"II"</span>]</code></pre>

      </section><section class="slide" id="slide-32-5">
        <h2 id="polynomiale-regression">Polynomiale Regression</h2>
<p>Wir nähern die Daten mit einer Polynomfunktion vom Grad 3 an:</p>
<pre><code class="language-py"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> PolynomialFeatures
poly_model = make_pipeline(
    PolynomialFeatures(<span class="hljs-number">3</span>),
    LinearRegression()
)

poly_model.fit(X, y)</code></pre>
<p>Aufgabe: Vergleiche die Ergebnisse einer einfachen Linearen Regression mit der polynomialen Regression.</p>

      </section></section><section class="section" id="section-33"><section class="slide" id="slide-33-1">
        <h1 id="klassifizierung">Klassifizierung</h1>

      </section><section class="slide" id="slide-33-2">
        <h2 id="klassifizierungsalgorithmen">Klassifizierungsalgorithmen</h2>
<ul>
<li>K-Nearest-Neighbors</li>
<li>Logistische Regression</li>
<li>Naive Bayes</li>
<li>Support Vector Machine</li>
<li>Entscheidungsbäume und Random Forests</li>
</ul>
<p>Siehe auch: <a href="https://scikit-learn.org/stable/auto_examples/classification/plot_classifier_comparison.html">classifier comparison von scikit-learn</a></p>

      </section><section class="slide" id="slide-33-3">
        <h2 id="k-nearest-neighbors">K-Nearest-Neighbors</h2>
<p>Ein neuer Datenpunkt wird klassifiziert, indem seine nächsten Nachbarn betrachtet werden. Die bei diesen Nachbarn am häufigsten vorkommende Klasse wird auch für den Datenpunkt festgesetzt.</p>
<p>Die Anzahl <code>k</code> der betrachteten Nachbarn kann festgesetzt werden (Standardwert = 5)</p>
<p>Siehe auch: <a href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier">https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier</a></p>

      </section><section class="slide" id="slide-33-4">
        <h2 id="logistische-regression">Logistische Regression</h2>
<p>An einer Grenze zwischen zwei Klassen wird mit Hilfe einer <em>logistischen Funktion</em> angegeben, wie groß die Wahrscheinlichkeit ist, dass der Datenpunkt zu der einen (bzw zu der anderen) Klasse gehört. Je nachdem, welche der Wahrscheinlichkeiten größer als 50% ist, wird die entsprechende Klasse zugewiesen.</p>
<p>Die logistische Funktion selbst wird intern mittels Regression bestimmt (daher der Name).</p>
<p>Beispiel: <a href="https://scikit-learn.org/stable/auto_examples/linear_model/plot_logistic.html#sphx-glr-auto-examples-linear-model-plot-logistic-py">https://scikit-learn.org/stable/auto_examples/linear_model/plot_logistic.html#sphx-glr-auto-examples-linear-model-plot-logistic-py</a></p>

      </section><section class="slide" id="slide-33-5">
        <h2 id="naive-bayes">Naive Bayes</h2>
<p>Für die bekannten Klassen werden Wahrscheinlichkeitsverteilungen angenommen (z.B. Normalverteilung, Multinomialverteilung). Diese Verteilungen werden aus den Trainingsdaten hergeleitet.</p>
<p>Für einen neuen Datenpunkt wird dann errechnet, unter welcher der Verteilungen er am ehesten auftreten würde.</p>
<p>Zwei wichtige Verteilungen sind die Normalverteilung (Gauß&#39;sche Verteilung) für kontinuierliche Werte und die Multinomialverteilung für diskrete Werte (Ganzzahlen).</p>
<p><a href="https://jakevdp.github.io/PythonDataScienceHandbook/05.05-naive-bayes.html">Python Data Science Handbook - Naive Bayes</a></p>

      </section><section class="slide" id="slide-33-6">
        <h2 id="support-vector-machines">Support Vector Machines</h2>
<p>Einfachster Fall: Trennung von Klassen durch Geraden / Ebenen / Hyperebenen - diese Trenner sollen von den getrennten Punkten maximalen Abstand haben.</p>
<p>Durch Kernelfunktionen können die Grenzen auch andere Formen annehmen, z.B. die von Kegelschnitten für polynomiale Kernel vom Grad 2 oder anderen Kurven.</p>
<p>Siehe auch: <a href="https://scikit-learn.org/stable/modules/svm.html">https://scikit-learn.org/stable/modules/svm.html</a></p>
<p><a href="https://jakevdp.github.io/PythonDataScienceHandbook/05.07-support-vector-machines.html">Python Data Science Handbook - Support Vector Machines</a></p>

      </section><section class="slide" id="slide-33-7">
        <h2 id="entscheidungsbäume-decision-trees">Entscheidungsbäume (Decision Trees)</h2>
<p>Machine Learning Bibliotheken können sogenannte Entscheidungsbäume auf Basis von Trainingsdaten generieren.</p>
<p>Beispiel für einen Entscheidungsbaum für die Iris-Klassifizierung:</p>
<ul>
<li>Ist die <em>petal length</em> kleiner oder gleich 2.4?<ul>
<li>ja: <strong>setosa</strong></li>
<li>nein: Ist die <em>petal width</em> kleiner oder gleich 1.7?<ul>
<li>ja: Ist die <em>petal length</em> kleiner oder gleich 5.0?<ul>
<li>ja: <strong>versicolor</strong></li>
<li>nein: <strong>virginica</strong></li>
</ul>
</li>
<li>nein: <strong>virginica</strong></li>
</ul>
</li>
</ul>
</li>
</ul>

      </section><section class="slide" id="slide-33-8">
        <h2 id="random-forests">Random Forests</h2>
<p>Basierend auf Decision Trees: Die Daten werden in verschiedene Untermengen zerlegt. Mittels jeder Untermenge wird ein einzelner Decision Tree erstellt. Die Gesamtheit der Decision Trees wird zu einem sogenannten <em>Random Forest</em> zusammengeführt.</p>
<p><a href="https://jakevdp.github.io/PythonDataScienceHandbook/05.08-random-forests.html">Python Data Science Handbook - Decision Trees and Random Forests</a></p>

      </section><section class="slide" id="slide-33-9">
        <h2 id="klassifizierungsalgorithmen---übersicht">Klassifizierungsalgorithmen - Übersicht</h2>
<p>Mögliche Algorithmen:</p>
<pre><code class="language-py"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier
<span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> GaussianNB
<span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> MultinomialNB
<span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression
<span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC
<span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier
<span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier</code></pre>
<!--
```py
LogisticRegression(solver="liblinear", multi_class="auto")
SVC(gamma="scale")
RandomForestClassifier(n_estimators=100)
```
-->


      </section><section class="slide" id="slide-33-10">
        <h2 id="beispiele-zur-klassifizierung">Beispiele zur Klassifizierung</h2>
<ul>
<li><a href="https://jakevdp.github.io/PythonDataScienceHandbook/05.05-naive-bayes.html#Multinomial-Naive-Bayes">Klassifizierung von Newsgroup-Postings (mittels Naive Bayes, logistischer Regression oder Decision Tree)</a></li>
<li><a href="https://jakevdp.github.io/PythonDataScienceHandbook/05.08-random-forests.html#Example:-Random-Forest-for-Classifying-Digits">Erkennen von Ziffern (Random Forest)</a></li>
</ul>

      </section></section><section class="section" id="section-34"><section class="slide" id="slide-34-1">
        <h1 id="overfitting">Overfitting</h1>

      </section><section class="slide" id="slide-34-2">
        <h2 id="overfitting">Overfitting</h2>
<p>Mögliches Problem beim Lernen: Der Algorithmus ist zu flexibel und erkennt scheinbare Muster in zufälligen Schwankungen.</p>
<p>Algorithmen, die anfällig für Overfitting sind:</p>
<ul>
<li>Entscheidungsbäume</li>
<li>Polynomiale Regression</li>
</ul>

      </section><section class="slide" id="slide-34-3">
        <h2 id="overfitting---lösungmöglichkeiten">Overfitting - Lösungmöglichkeiten</h2>
<ul>
<li>Einschränkung der Flexibilität (z.B. Grad des Polynoms, Tiefe des Entscheidungsbaums)</li>
<li>Kombination mehrerer Entscheidungsbäume (Random Forest)</li>
<li>&quot;Bestrafung&quot; großer Koeffizienten bei der polynomialen Regression (L2- und L1-Regularisierung)</li>
</ul>
<p>Zur polynomialen Regression siehe: <a href="https://jakevdp.github.io/PythonDataScienceHandbook/05.06-linear-regression.html#Regularization">Data Science Handbook - Regularization</a></p>

      </section></section><section class="section" id="section-35"><section class="slide" id="slide-35-1">
        <h1 id="modellbewertung--verbesserung">Modellbewertung &amp; Verbesserung</h1>

      </section><section class="slide" id="slide-35-2">
        <h2 id="modellbewertung--verbesserung">Modellbewertung &amp; Verbesserung</h2>
<p>Um das bestmögliche Modell zu bestimmen:</p>
<ul>
<li>Testen mehrerer Algorithmen</li>
<li>Testen mehrerer Parameter für den Algorithmus</li>
<li>Testen, ob mehr Lerndaten zu besseren Ergebnissen führen</li>
</ul>
<p>siehe <a href="https://jakevdp.github.io/PythonDataScienceHandbook/05.03-hyperparameters-and-model-validation.html#Selecting-the-Best-Model">Python Data Science Handbook → Hyperparameters and Model Validation → Selecting the Best Model</a></p>

      </section></section><section class="section" id="section-36"><section class="slide" id="slide-36-1">
        <h1 id="clustering">Clustering</h1>

      </section><section class="slide" id="slide-36-2">
        <h2 id="clustering">Clustering</h2>
<p>Beim Clustering handelt es sich um <em>unsupervised learning</em>. Solche Algorithmen haben keine Zieldaten (<em>y</em>), sondern suchen nur in den Ausgangsdaten nach einer bestimmten Struktur.</p>
<p>Ziel von Clustering ist es, in vorhandenen Daten Gruppierungen (Cluster) von Datenpunkten zu finden.</p>

      </section><section class="slide" id="slide-36-3">
        <h2 id="clustering">Clustering</h2>
<ul>
<li><em>k-Means Clustering</em></li>
<li><em>Gaussian Mixture Models</em></li>
</ul>

      </section><section class="slide" id="slide-36-4">
        <h2 id="k-means-clustering">k-Means Clustering</h2>
<p>Zum Verfahren: Es werden im n-dimensionalen Raum gewisse Clusterzentren bestimmt. Ein Datenpunkt wird zu jenem Cluster gezählt, zu dessen Zentrum er den geringsten Abstand hat.</p>
<p>Bestimmung der Clusterzentren:</p>
<p>Initialisierung: zufällige Festlegung der Zentren</p>
<p>Wiederholt:</p>
<ul>
<li>bestimmen der Zugehörigkeit jedes Datenpunktes basierend auf den Zentren</li>
<li>neue Festlegung der Zentren als Mittel der ihm zugeordneten Punkte</li>
</ul>
<p>Dieses Verfahren konvergiert.</p>
<p><a href="https://jakevdp.github.io/PythonDataScienceHandbook/05.11-k-means.html">Python Data Science Handbook - k-Means Clustering</a></p>

      </section><section class="slide" id="slide-36-5">
        <h2 id="k-means-clustering">k-Means Clustering</h2>
<p>Beispiele:</p>
<ul>
<li><a href="https://jakevdp.github.io/PythonDataScienceHandbook/05.11-k-means.html#Example-1:-k-means-on-digits">Anwendung auf Ziffern</a></li>
<li><a href="https://jakevdp.github.io/PythonDataScienceHandbook/05.11-k-means.html#Example-2:-k-means-for-color-compression">Farbkomprimierung von Bildern</a></li>
</ul>

      </section></section><section class="section" id="section-37"><section class="slide" id="slide-37-1">
        <h1 id="resources">Resources</h1>
<p>Pandas website: <a href="https://pandas.pydata.org/">https://pandas.pydata.org/</a></p>
<p>Python Data Science Handbook: <a href="https://jakevdp.github.io/PythonDataScienceHandbook/">https://jakevdp.github.io/PythonDataScienceHandbook/</a></p>
<!-- https://github.com/jakevdp/PythonDataScienceHandbook -->


      </section></section>

    </div>
    <div id="navigation-arrows">
      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="navigation-arrows-svg"
        xml:space="preserve" width="100%" height="100%" viewBox="-110 -110 220 220">
        <path class="arrow right" d="M70,-30L100,0L70,30" />
        <path class="arrow down" d="M-30,70L0,100L30,70" />
        <path class="arrow left" d="M-70,-30L-100,0L-70,30" />
        <path class="arrow up" d="M-30,-70L0,-100L30,-70" />
      </svg>
    </div>
  </div>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      width: 100vw;
      height: 100vh;
      margin: 0px;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: rgb(150, 150, 150);
      font-family: -apple-system, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
      line-height: 1.5rem;
    }

    p, ul, pre {
      margin-top: 0;
    }

    ul {
      padding-left: 1.5rem;
    }

    h1, h2, h3 {
      margin-top: 0px;
      font-weight: 600;
    }

    h1 {
      margin-top: 5vh;
      text-align: center;
      font-size: 2rem;
    }

    h2 {
      margin-bottom: 1.5em;
    }

    svg {
      width: 100%;
      height: auto;
    }

    .section {
      height: 100%;
      display: none;
    }

    .section.active {
      display: block;
    }

    .slide {
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    .slide.inactive {
      display: none;
    }

    #canvas {
      box-shadow: 0 0.5vh 1vh rgba(0, 0, 0, 0.3);
      background-color: #f8f8f8;
      position: relative;
      display: flex;
    }

    #canvas-content {
      width: 100%;
      height: 100%;
    }

    #canvas-content .note {
      display: none;
    }

    #canvas-content img {
      margin: 0px auto;
      display: block;
    }

    @media (min-aspect-ratio: 8/5) {

      html {
        font-size: 3.5vh;
      }

      /* wide screen */
      #canvas {
        width: calc(100vh / 5 * 8);
        height: 100vh;
        padding: 10vh;
        padding-top: 5vh;
      }
    }

    @media (max-aspect-ratio: 8/5) {

      html {
        font-size: calc(3.5vw * 5 / 8);
      }

      /* narrow screen */
      #canvas {
        width: 100vw;
        height: calc(100vw * 5 / 8);
        padding: calc(10vh * 5 / 8);
        padding-top: calc(5vh * 5 / 8);
      }
    }

    pre {
      background-color: rgb(224, 233, 240);
      box-shadow: 0 0.5vh 1vh rgba(0, 0, 0, 0.2);
      padding: 0.5em 1em;
      line-height: 1.2em;
      overflow: auto;
    }

    #navigation-arrows {
      position: absolute;
      right: 2rem;
      top: 2rem;
      height: 3rem;
      width: 3rem;
    }

    #navigation-arrows .arrow {
      stroke: lightblue;
      /*stroke-width: 0.8em; Chrome behaves differently with ems here */
      stroke-width: 16px;
      stroke-linecap: round;
      fill: none;
      cursor: pointer;
    }

    td,
    th {
      padding: 0.2em 0.8em;
    }

    th {
      text-align: start;
    }
  </style>
  <script>
    let presenterWindow;
    let activeSlide;
    let slideCount;

    const arrowUp = document.querySelector('.arrow.up');
    const arrowDown = document.querySelector('.arrow.down');
    const arrowRight = document.querySelector('.arrow.right');
    const arrowLeft = document.querySelector('.arrow.left');
    arrowUp.addEventListener('click',
      () => {activateSlideSafe(activeSlide[0], activeSlide[1] - 1);}
    );
    arrowDown.addEventListener('click',
      () => {activateSlideSafe(activeSlide[0], activeSlide[1] + 1);}
    );
    arrowLeft.addEventListener('click',
      () => {activateSlideSafe(activeSlide[0] - 1, 1);}
    );
    arrowRight.addEventListener('click',
      () => {activateSlideSafe(activeSlide[0] + 1, 1);}
    )
    const init = () => {
      slideCount = countSlides();
      activateSlideSafe(1, 1);
      addKeyControls();
      addSwipeControls();
      hideNoScriptMessage();
    }

    // count slides
    const countSlides = () => {
      const counts = [];
      return [...document.querySelectorAll('.section')].map(section => section.childNodes.length);
    }

    const updateVisible = () => {
      for (let section of document.querySelectorAll('.section')) {
        if (section.id === `section-${activeSlide[0]}`) {
          section.className = 'section active';
        } else {
          section.className = 'section inactive';
        }
      }
      for (let slide of document.querySelectorAll('.slide')) {
        if (slide.id === `slide-${activeSlide[0]}-${activeSlide[1]}`) {
          slide.className = 'slide active';
        } else {
          slide.className = 'slide inactive';
        }
      }
    }

    const updatePageArrows = () => {
      if (slideCount.length === 1) {
        arrowLeft.style.opacity = "0";
        arrowRight.style.opacity = "0";
      } else {
        const progressSections = (activeSlide[0] - 1) / (slideCount.length - 1);
        arrowLeft.style.opacity = progressSections.toString();
        arrowRight.style.opacity = (1 - progressSections).toString();
      }
      const slidesInActiveSection = slideCount[activeSlide[0] - 1]
      if (slidesInActiveSection === 1) {
        arrowUp.style.opacity = "0";
        arrowDown.style.opacity = "0";
      } else {
        const progressSlides = (activeSlide[1] - 1) / (slidesInActiveSection - 1);
        arrowUp.style.opacity = progressSlides.toString();
        arrowDown.style.opacity = (1 - progressSlides).toString();
      }
    }

    /**
     * Activate a slide if it exists, else do nothing
    */
    const activateSlideSafe = (sectionIndex, slideIndex) => {
      if (1 <= sectionIndex && sectionIndex <= slideCount.length && 1 <= slideIndex && slideIndex <= slideCount[sectionIndex - 1]) {
        activeSlide = [sectionIndex, slideIndex];
        updateVisible();
        updatePageArrows();
        scrolltoActiveSlide();
      }
    }

    const activateSlideNextSafe = () => {
      if (activeSlide[1] === slideCount[activeSlide[0] - 1]) {
        activateSlideSafe(activeSlide[0] + 1, 1);
      } else {
        activateSlideSafe(activeSlide[0], activeSlide[1] + 1);
      }
    }

    const activateSlideRightSafe = () => {
      activateSlideSafe(activeSlide[0] + 1, 1);
    }

    const activateSlideLeftSafe = () => {
      activateSlideSafe(activeSlide[0] - 1, 1);
    }

    const activateSlideDownSafe = () => {
      activateSlideSafe(activeSlide[0], activeSlide[1] + 1);
    }

    const activateSlideUpSafe = () => {
      activateSlideSafe(activeSlide[0], activeSlide[1] - 1);
    }

    const scrolltoActiveSlide = () => {
      const slideId = `#slide-${activeSlide[0]}-${activeSlide[1]}`;
      if (presenterWindow) {
        const activeSlide = presenterWindow.document.querySelector(slideId);
        if (activeSlide) {
          activeSlide.scrollIntoView();
        }
      }
    }

    const addKeyControls = () => {
      document.querySelector('body').addEventListener('keydown', event => {
        if (event.key === 'p') {
          const canvasContent = document.querySelector('#canvas-content').innerHTML;
          presenterWindow = window.open(document.URL, '_blank');
          presenterWindow.onload = () => {
            presenterWindow.document.querySelector('body').innerHTML = canvasContent;
          }
        }
        if (event.key === 'ArrowRight') {
          activateSlideRightSafe();
        } else if (event.key === 'ArrowLeft') {
          activateSlideLeftSafe();
        } else if (event.key === 'ArrowDown') {
          activateSlideDownSafe();
        } else if (event.key === 'ArrowUp') {
          activateSlideUpSafe();
        } else if (event.key === 'Enter') {
          activateSlideNextSafe();
        }
      });
    }

    const addSwipeControls = () => {

      const distance = 100;

      let startPos;
      let handled;

      document.addEventListener('touchstart', event => {
        startPos = event.touches[0];
        handled = false;
      });

      document.addEventListener('touchmove', event => {
        if (!handled) {
          let currentPos = event.touches[0];
          const xDiff = currentPos.clientX - startPos.clientX;
          const yDiff = currentPos.clientY - startPos.clientY;
          if (Math.abs(xDiff) > 2*Math.abs(yDiff) ||
              Math.abs(yDiff) > 2*Math.abs(xDiff)) {
            if (xDiff > distance) {
              activateSlideLeftSafe();
              handled = true;
            } else if (xDiff < -distance) {
              activateSlideRightSafe();
              handled = true;
            } else if (yDiff > distance) {
              activateSlideUpSafe();
              handled = true;
            } else if (yDiff < -distance) {
              activateSlideDownSafe();
              handled = true;
            }
          }
        }
      });
    }

    const hideNoScriptMessage = () => {
      document.querySelector("#no-script").innerHTML = "";
    }

    init();

  </script>
</body>

</html>